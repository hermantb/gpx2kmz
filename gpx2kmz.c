/* Copyright 2019 Herman ten Brugge
 *
 * Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
 * http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
 * <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
 * option. This file may not be copied, modified, or distributed
 * except according to those terms.
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <ctype.h>
#include <unistd.h>
#include <time.h>
#include <math.h>
#include <dirent.h>

#ifdef __linux__
#define	LINUX 1
#else
#define	LINUX 0
#endif

#if LINUX

#define	FILE_SEP_STR		"/"
#define	FILE_SEP_CHR		'/'
#define	MKDIR(x)		mkdir (x, 0777)

#include <expat.h>

#include <libexif/exif-data.h>
#include <libexif/exif-utils.h>
#include <libexif/exif-loader.h>

#else

#define	FILE_SEP_STR		"\\"
#define	FILE_SEP_CHR		'\\'
#define	MKDIR(x)		mkdir (x)

#define XMLCALL
#define XML_Char		char
#define XML_FALSE       	0
#define XML_STATUS_ERROR        (-1)
#define XML_HEADER_ERROR        (-2)
#define XML_MISSING_START       (-3)
#define XML_MISSING_IDENTIFIER  (-4)
#define XML_WRONG_ENDTAG        (-5)
#define XML_PARSER_STOP         (-6)
#define XML_MISSING_END         (-7)
#define XML_MISSING_EQUAL       (-8)
#define XML_MISSING_QUOTE       (-9)
#define XML_MEMORY_ERROR        (-10)

#define	XML_HEADER		"<?xml "

#if defined(__GNUC__) && !defined(__QAC__)
#define ATTRIBUTE_UNUSED        __attribute__ ((__unused__))
#else
#define ATTRIBUTE_UNUSED
#endif

typedef struct XML_ParserStruct *XML_Parser;
typedef void (*XML_StartElementHandler) (void *userData,
					 const XML_Char * name,
					 const XML_Char ** atts);
typedef void (*XML_StartCdataSectionHandler) (void *userData);
typedef void (*XML_EndCdataSectionHandler) (void *userData);
typedef void (*XML_EndElementHandler) (void *userData, const XML_Char * name);
typedef void (*XML_CharacterDataHandler) (void *userData,
					  const XML_Char * s, int len);
static int XML_GetCurrentLineNumber (XML_Parser parser);
static int XML_StopParser (XML_Parser parser, int resumable);
static int XML_Parse (XML_Parser parser, const char *buf, int len, int done);
static const char *XML_ErrorString (int errorcode);
static XML_Parser XML_ParserCreate (const char *encoding);
static void XML_SetElementHandler (XML_Parser parser,
				   XML_StartElementHandler start,
				   XML_EndElementHandler end);
static void XML_SetCdataSectionHandler (XML_Parser parser,
					XML_StartCdataSectionHandler start,
					XML_EndCdataSectionHandler end);
static void XML_SetCharacterDataHandler (XML_Parser parser,
					 XML_CharacterDataHandler charhndl);
static void XML_SetUserData (XML_Parser parser, void *userData);
static void XML_ParserFree (XML_Parser parser);
static int XML_GetErrorCode (XML_Parser parser);

typedef struct XML_ParserStruct
{
  int errorcode;
  int lineno;
  int stop;
  XML_StartElementHandler start;
  XML_EndElementHandler end;
  XML_StartCdataSectionHandler cstart;
  XML_EndCdataSectionHandler cend;
  XML_CharacterDataHandler charhndl;
  void *userData;
}
XML_ParserStruct;

static void xml_skip_whitespace (XML_Parser parser, const char **buf);
static int xml_get_identifier (const char **buf);

static int
XML_GetCurrentLineNumber (XML_Parser parser)
{
  return parser->lineno;
}

static int
XML_StopParser (XML_Parser parser, int resumable ATTRIBUTE_UNUSED)
{
  parser->stop = 1;
  return 0;
}

static void
xml_skip_whitespace (XML_Parser parser, const char **buf)
{
  const char *cp = *buf;

  for (;;) {
    while (*cp == ' ' || *cp == '\t' || *cp == '\n' || *cp == '\r') {
      parser->lineno += *cp++ == '\n';
    }
    if (*cp == '<' && cp[1] == '!' && cp[2] == '-' && cp[3] == '-') {
      cp += 4;
      while (*cp) {
	if (*cp == '-' && cp[1] == '-' && cp[2] == '>') {
	  cp += 3;
	  break;
	}
	parser->lineno += *cp++ == '\n';
      }
    }
    else {
      break;
    }
  }
  *buf = cp;
}

static int
xml_get_identifier (const char **buf)
{
  const char *cp = *buf;

  if ((*cp >= 'a' && *cp <= 'z') ||
      (*cp >= 'A' && *cp <= 'Z') || (*cp >= '0' && *cp <= '9')) {
    cp++;
    while ((*cp >= 'a' && *cp <= 'z') ||
	   (*cp >= 'A' && *cp <= 'Z') ||
	   (*cp >= '0' && *cp <= '9') || *cp == '_' || *cp == '-'
	   || *cp == ':' || *cp == '.') {
      cp++;
    }
    *buf = cp;
    return 1;
  }
  return 0;
}

static int
XML_Parse (XML_Parser parser, const char *buf, int len ATTRIBUTE_UNUSED,
	   int done ATTRIBUTE_UNUSED)
{
  int i;
  const char *tag;
  const char *text;
  char *result_text = NULL;
  char *new_result_text = NULL;
  int ntags = 0;
  char **tags = NULL;
  char **new_tags = NULL;
  int nattr = 0;
  char **attr = NULL;
  char **new_attr = NULL;
  int error = 0;
  int len_text = 0;
  int check_text;
  int cur_pos;
  int cdata;

  parser->lineno = 1;
  parser->stop = 0;
  parser->errorcode = 0;
  cdata = 0;
  if (strncmp (buf, XML_HEADER, strlen (XML_HEADER)) != 0) {
    parser->errorcode = XML_HEADER_ERROR;
    return XML_STATUS_ERROR;
  }
  buf += strlen (XML_HEADER);
  while (*buf && (buf[0] != '?' || buf[1] != '>')) {
    parser->lineno += *buf++ == '\n';
  }
  if (buf[0] == '?' && buf[1] == '>') {
    buf += 2;
  }
  xml_skip_whitespace (parser, &buf);
  while (*buf) {
    if (*buf != '<') {
      parser->errorcode = XML_MISSING_START;
      error = XML_STATUS_ERROR;
      break;
    }
    buf++;
    if (*buf == '/') {
      buf++;
      /* end */
      xml_skip_whitespace (parser, &buf);
      tag = buf;
      if (xml_get_identifier (&buf) == 0) {
	parser->errorcode = XML_MISSING_IDENTIFIER;
	error = XML_STATUS_ERROR;
	break;
      }
      if (ntags == 0 || (size_t) (buf - tag) != strlen (tags[ntags - 1]) ||
	  strncmp (tag, tags[ntags - 1], buf - tag) != 0) {
	parser->errorcode = XML_WRONG_ENDTAG;
	error = XML_STATUS_ERROR;
	break;
      }
      parser->end (parser->userData, tags[ntags - 1]);
      free (tags[--ntags]);
      if (parser->stop) {
	parser->errorcode = XML_PARSER_STOP;
	error = XML_STATUS_ERROR;
	break;
      }
      xml_skip_whitespace (parser, &buf);
      if (*buf != '>') {
	parser->errorcode = XML_MISSING_END;
	error = XML_STATUS_ERROR;
	break;
      }
      buf++;
    }
    else {
      /* start */
      nattr = 0;
      attr = NULL;
      xml_skip_whitespace (parser, &buf);
      tag = buf;
      if (xml_get_identifier (&buf) == 0) {
	parser->errorcode = XML_MISSING_IDENTIFIER;
	error = XML_STATUS_ERROR;
	break;
      }
      new_tags = (char **) realloc (tags, (ntags + 1) * sizeof (char *));
      if (new_tags == NULL) {
	parser->errorcode = XML_MEMORY_ERROR;
	error = XML_STATUS_ERROR;
	break;
      }
      tags = new_tags;
      tags[ntags] = (char *) malloc (buf - tag + 1);
      if (tags[ntags] == NULL) {
	parser->errorcode = XML_MEMORY_ERROR;
	error = XML_STATUS_ERROR;
	break;
      }
      strncpy (tags[ntags], tag, buf - tag);
      tags[ntags++][buf - tag] = '\0';
      xml_skip_whitespace (parser, &buf);
      while (*buf && *buf != '>' && (*buf != '/' || buf[1] != '>')) {
	tag = buf;
	if (xml_get_identifier (&buf) == 0) {
	  parser->errorcode = XML_MISSING_IDENTIFIER;
	  error = XML_STATUS_ERROR;
	  break;
	}
	new_attr = (char **) realloc (attr, (nattr + 1) * sizeof (char *));
	if (new_attr == NULL) {
	  parser->errorcode = XML_MEMORY_ERROR;
	  error = XML_STATUS_ERROR;
	  break;
	}
	attr = new_attr;
	attr[nattr] = (char *) malloc (buf - tag + 1);
	if (attr[nattr] == NULL) {
	  parser->errorcode = XML_MEMORY_ERROR;
	  error = XML_STATUS_ERROR;
	  break;
	}
	strncpy (attr[nattr], tag, buf - tag);
	attr[nattr++][buf - tag] = '\0';
	xml_skip_whitespace (parser, &buf);
	if (*buf != '=') {
	  parser->errorcode = XML_MISSING_EQUAL;
	  error = XML_STATUS_ERROR;
	  break;
	}
	buf++;
	xml_skip_whitespace (parser, &buf);
	if (*buf != '"') {
	  parser->errorcode = XML_MISSING_QUOTE;
	  error = XML_STATUS_ERROR;
	  break;
	}
	buf++;
	tag = buf;
	while (*buf && *buf != '"') {
	  parser->lineno += *buf++ == '\n';
	}
	if (*buf != '"') {
	  parser->errorcode = XML_MISSING_QUOTE;
	  error = XML_STATUS_ERROR;
	  break;
	}
	new_attr = (char **) realloc (attr, (nattr + 1) * sizeof (char *));
	if (new_attr == NULL) {
	  parser->errorcode = XML_MEMORY_ERROR;
	  error = XML_STATUS_ERROR;
	  break;
	}
	attr = new_attr;
	attr[nattr] = (char *) malloc (buf - tag + 1);
	if (attr[nattr] == NULL) {
	  parser->errorcode = XML_MEMORY_ERROR;
	  error = XML_STATUS_ERROR;
	  break;
	}
	strncpy (attr[nattr], tag, buf - tag);
	attr[nattr++][buf - tag] = '\0';
	buf++;
	xml_skip_whitespace (parser, &buf);
      }
      if (error) {
	break;
      }
      new_attr = (char **) realloc (attr, (nattr + 1) * sizeof (char *));
      if (new_attr == NULL) {
	parser->errorcode = XML_MEMORY_ERROR;
	error = XML_STATUS_ERROR;
	break;
      }
      attr = new_attr;
      attr[nattr++] = NULL;
      parser->start (parser->userData, tags[ntags - 1], (const char **) attr);
      for (i = 0; i < nattr; i++) {
	free (attr[i]);
      }
      free (attr);
      attr = NULL;
      if (parser->stop) {
	parser->errorcode = XML_PARSER_STOP;
	error = XML_STATUS_ERROR;
	break;
      }
      check_text = 1;
      if (*buf == '/') {
	parser->end (parser->userData, tags[ntags - 1]);
	if (parser->stop) {
	  parser->errorcode = XML_PARSER_STOP;
	  error = XML_STATUS_ERROR;
	  break;
	}
	free (tags[--ntags]);
	buf++;
	check_text = 0;
      }
      if (*buf != '>') {
	parser->errorcode = XML_MISSING_END;
	error = XML_STATUS_ERROR;
	break;
      }
      buf++;
      if (check_text) {
	text = buf;
	cur_pos = parser->lineno;
	xml_skip_whitespace (parser, &buf);
	if (*buf != '<' ||
	    (*buf == '<' && buf[1] == '!' && buf[2] == '[' &&
	     strncmp (buf, "<![CDATA[", strlen ("<![CDATA[")) == 0)) {
	  parser->lineno = cur_pos;
	  cur_pos = 0;
	  if (len_text == 0) {
	    len_text = 1024;
	    result_text = (char *) malloc (len_text);
	    if (result_text == NULL) {
	      parser->errorcode = XML_MEMORY_ERROR;
	      error = XML_STATUS_ERROR;
	      break;
	    }
	  }
	  buf = text;
	  while (*buf) {
	    if (cdata == 0 && *buf == '<' && buf[1] == '!' && buf[2] == '-'
		&& buf[3] == '-') {
	      buf += 4;
	      while (*buf) {
		if (*buf == '-' && buf[1] == '-' && buf[2] == '>') {
		  buf += 3;
		  break;
		}
		parser->lineno += *buf++ == '\n';
	      }
	    }
	    else if (cdata == 0 &&
		     *buf == '<' && buf[1] == '!' && buf[2] == '[' &&
		     strncmp (buf, "<![CDATA[", strlen ("<![CDATA[")) == 0) {
	      cdata = 1;
	      buf += strlen ("<![CDATA[");
	      result_text[cur_pos] = '\0';
	      if (parser->charhndl) {
		parser->charhndl (parser->userData, result_text, cur_pos);
	      }
	      if (parser->cstart) {
		parser->cstart (parser->userData);
	      }
	      cur_pos = 0;
	    }
	    else if (cdata && *buf == ']' && buf[1] == ']' && buf[2] == '>') {
	      cdata = 0;
	      buf += 3;
	      result_text[cur_pos] = '\0';
	      if (parser->charhndl) {
		parser->charhndl (parser->userData, result_text, cur_pos);
	      }
	      if (parser->cend) {
		parser->cend (parser->userData);
	      }
	      cur_pos = 0;
	    }
	    else if (cdata || *buf != '<') {
	      parser->lineno += *buf == '\n';
	      result_text[cur_pos++] = *buf++;
	      if (cur_pos >= len_text - 1) {
		len_text += 1024;
		new_result_text = (char *) realloc (result_text, len_text);
		if (new_result_text == NULL) {
		  parser->errorcode = XML_MEMORY_ERROR;
		  error = XML_STATUS_ERROR;
		  break;
		}
		result_text = new_result_text;
	      }
	    }
	    else {
	      break;
	    }
	  }
	  if (error) {
	    break;
	  }
	  result_text[cur_pos] = '\0';
	  if (parser->charhndl) {
	    parser->charhndl (parser->userData, result_text, cur_pos);
	  }
	}
      }
    }
    xml_skip_whitespace (parser, &buf);
  }
  if (attr) {
    for (i = 0; i < nattr; i++) {
      free (attr[i]);
    }
    free (attr);
  }
  if (tags) {
    for (i = 0; i < ntags; i++) {
      free (tags[i]);
    }
    free (tags);
  }
  free (result_text);
  return error;
}

static const char *
XML_ErrorString (int errorcode)
{
  switch (errorcode) {
  case 0:
    return "OK";
  case XML_HEADER_ERROR:
    return "XML header error";
  case XML_MISSING_START:
    return "Missing '<'";
  case XML_MISSING_IDENTIFIER:
    return "Missing identifier";
  case XML_WRONG_ENDTAG:
    return "Wrong endtag";
  case XML_PARSER_STOP:
    return "Parser stopped";
  case XML_MISSING_END:
    return "Missing '>'";
  case XML_MISSING_EQUAL:
    return "Missing '='";
  case XML_MISSING_QUOTE:
    return "Missing '\"'";
  case XML_MEMORY_ERROR:
    return "Memory error";
  default:
    return "???";
  }
}

static XML_Parser
XML_ParserCreate (const char *encoding ATTRIBUTE_UNUSED)
{
  XML_Parser parser;

  parser = (XML_Parser) malloc (sizeof (*parser));
  if (parser) {
    memset (parser, 0, sizeof (*parser));
  }
  return parser;
}

static void
XML_SetElementHandler (XML_Parser parser, XML_StartElementHandler start,
		       XML_EndElementHandler end)
{
  parser->start = start;
  parser->end = end;
}

static void
XML_SetCdataSectionHandler (XML_Parser parser,
			    XML_StartCdataSectionHandler start,
			    XML_EndCdataSectionHandler end)
{
  parser->cstart = start;
  parser->cend = end;
}

static void
XML_SetCharacterDataHandler (XML_Parser parser,
			     XML_CharacterDataHandler charhndl)
{
  parser->charhndl = charhndl;
}

static void
XML_SetUserData (XML_Parser parser, void *userData)
{
  parser->userData = userData;
}

static void
XML_ParserFree (XML_Parser parser)
{
  free (parser);
}

static int
XML_GetErrorCode (XML_Parser parser)
{
  return parser->errorcode;
}

#endif

#define	RAD(x)	((x) * M_PI / 180.0)

#define SSORT(S_base,S_nel,S_width,S_comp)                              \
{                                                                       \
      size_t S_wnel, S_gap, S_wgap, S_i, S_j, S_k;                      \
      char   *S_a, *S_b, S_tmp;                                         \
                                                                        \
      S_wnel = (S_width) * (S_nel);                                     \
      for (S_gap = 0; ++S_gap < (S_nel);)                               \
            S_gap *= 3;                                                 \
      while ( S_gap /= 3 )                                              \
      {                                                                 \
            S_wgap = (S_width) * S_gap;                                 \
            for (S_i = S_wgap; S_i < S_wnel; S_i += (S_width))          \
            {                                                           \
                  for (S_j = S_i - S_wgap; ;S_j -= S_wgap)              \
                  {                                                     \
                        S_a = S_j + (char *)(S_base);                   \
                        S_b = S_a + S_wgap;                             \
                        if ( (S_comp)(S_a, S_b) <= 0 )                  \
                              break;                                    \
                        S_k = (S_width);                                \
                        do                                              \
                        {                                               \
                              S_tmp = *S_a;                             \
                              *S_a++ = *S_b;                            \
                              *S_b++ = S_tmp;                           \
                        } while ( --S_k );                              \
                        if (S_j < S_wgap)                               \
                              break;                                    \
                  }                                                     \
            }                                                           \
      }                                                                 \
}

typedef struct gpx_data_struct
{
  char *lat;
  char *lon;
  char *ele;
  char *time;
  double tim;
  int valid;
  double total_distance;
  double distance;
  double speed;
  double heading;
} gpx_data_type;

typedef struct track_struct
{
  char *track_name;
  unsigned int n_gpx_data;
  gpx_data_type *gpx_data;
} track_type;

typedef struct pict_struct
{
  char *name;
  unsigned int is_video;
  char *time;
  double tim;
  char *manufacturer;
  char *model;
  char *exposure_time;
  char *f_number;
  char *iso_speed_ratings;
  char *flash;
  char *duration;
  char *pixel_x_dimension;
  char *pixel_y_dimension;
  char *focal_length_in_35mm;
} pict_type;

static unsigned int n_gpx_data;
static gpx_data_type *gpx_data;
static gpx_data_type gpx_tmp;
static char *track_name;
static unsigned int start_cdata = 0;
static unsigned int n_track;
static track_type *track;
static unsigned int n_pict;
static pict_type *pict;
static unsigned int n_cache;
static pict_type *cache;
static unsigned int state;
static unsigned int use_video = 0;
static unsigned int use_jhead = 0;
static unsigned int use_exiftool = 0;
static unsigned int use_recursive = 0;
static unsigned int use_cache = 0;
static int fix_mp4 = 0;

static const char camera[] = {
  0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a,
  0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52,
  0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40,
  0x08, 0x06, 0x00, 0x00, 0x00, 0xaa, 0x69, 0x71,
  0xde, 0x00, 0x00, 0x00, 0x04, 0x67, 0x41, 0x4d,
  0x41, 0x00, 0x00, 0xb1, 0x8f, 0x0b, 0xfc, 0x61,
  0x05, 0x00, 0x00, 0x00, 0x01, 0x73, 0x52, 0x47,
  0x42, 0x00, 0xae, 0xce, 0x1c, 0xe9, 0x00, 0x00,
  0x00, 0x20, 0x63, 0x48, 0x52, 0x4d, 0x00, 0x00,
  0x7a, 0x25, 0x00, 0x00, 0x80, 0x83, 0x00, 0x00,
  0xf9, 0xff, 0x00, 0x00, 0x80, 0xe9, 0x00, 0x00,
  0x75, 0x30, 0x00, 0x00, 0xea, 0x60, 0x00, 0x00,
  0x3a, 0x98, 0x00, 0x00, 0x17, 0x6f, 0x92, 0x5f,
  0xc5, 0x46, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48,
  0x59, 0x73, 0x00, 0x00, 0x0b, 0x13, 0x00, 0x00,
  0x0b, 0x13, 0x01, 0x00, 0x9a, 0x9c, 0x18, 0x00,
  0x00, 0x06, 0xef, 0x49, 0x44, 0x41, 0x54, 0x78,
  0xda, 0xed, 0x9a, 0x7f, 0x4c, 0x95, 0x55, 0x18,
  0xc7, 0xaf, 0x66, 0xea, 0x14, 0x41, 0x5d, 0x21,
  0xe6, 0xcd, 0x94, 0xb5, 0xf9, 0x63, 0x40, 0x8a,
  0x29, 0x30, 0xa0, 0x41, 0xe5, 0x94, 0xd4, 0x29,
  0x0e, 0x17, 0x69, 0x3a, 0xd1, 0x26, 0x53, 0x54,
  0x2e, 0x98, 0x57, 0x49, 0x14, 0xcb, 0x89, 0xf3,
  0x47, 0xa2, 0xa9, 0xe8, 0x5c, 0x4e, 0x44, 0x26,
  0x34, 0x30, 0x89, 0x2b, 0x85, 0x95, 0x51, 0x32,
  0x22, 0xd1, 0x05, 0x65, 0xd3, 0x86, 0x1a, 0xa9,
  0xf9, 0x93, 0x04, 0x33, 0x72, 0xcd, 0x35, 0x4f,
  0xcf, 0x79, 0xf7, 0x3d, 0x77, 0x2f, 0x2f, 0xf7,
  0xc2, 0xb9, 0x97, 0xfb, 0xb2, 0xc2, 0xf7, 0xdd,
  0x3e, 0x7f, 0xdc, 0xfb, 0x9e, 0x73, 0x9e, 0xe7,
  0xf9, 0xbe, 0xe7, 0x3d, 0x3f, 0x9e, 0xf7, 0x98,
  0x18, 0x63, 0xa6, 0xc7, 0x19, 0x93, 0x21, 0x80,
  0x21, 0x80, 0x21, 0x80, 0x21, 0x80, 0x21, 0x80,
  0x21, 0x80, 0x21, 0x80, 0x21, 0x80, 0x21, 0x80,
  0x21, 0x80, 0x21, 0xc0, 0xe3, 0x29, 0x40, 0x1b,
  0x57, 0x77, 0x62, 0x00, 0x31, 0xcc, 0x05, 0x06,
  0xa0, 0x9e, 0xcc, 0xd5, 0x8d, 0xe8, 0x0f, 0xba,
  0xb9, 0xe0, 0x83, 0x2b, 0x36, 0xdc, 0xba, 0xbc,
  0x88, 0x60, 0xe2, 0x65, 0x22, 0x96, 0x98, 0xef,
  0x02, 0xb1, 0xa8, 0x67, 0x76, 0xd2, 0xf6, 0x40,
  0xc2, 0x1f, 0xed, 0x47, 0x13, 0x33, 0x40, 0x34,
  0xfe, 0xf3, 0x52, 0x95, 0x35, 0x3b, 0xf1, 0x41,
  0xd8, 0xe0, 0xed, 0xf4, 0xd6, 0x23, 0xf8, 0x28,
  0x62, 0x11, 0xb1, 0x9e, 0xd8, 0x41, 0x1c, 0x74,
  0x01, 0x5e, 0xde, 0x4a, 0xbc, 0xe6, 0x40, 0x84,
  0x00, 0x38, 0x9f, 0x40, 0x58, 0xd0, 0x7e, 0x16,
  0x58, 0x0f, 0x9b, 0x51, 0xf0, 0xc1, 0x8c, 0x36,
  0xac, 0x0e, 0x7c, 0x10, 0x36, 0x16, 0x10, 0x11,
  0x9e, 0x16, 0x21, 0x18, 0x8e, 0xec, 0x27, 0xca,
  0x89, 0x5a, 0xa2, 0xde, 0x05, 0x78, 0xf9, 0x3c,
  0x38, 0xc8, 0x9f, 0x52, 0x2f, 0x4d, 0xf0, 0x1b,
  0x89, 0x1c, 0xa2, 0x18, 0xed, 0xd7, 0x80, 0x72,
  0xd8, 0x5c, 0xa4, 0xea, 0x7d, 0x56, 0xb4, 0x55,
  0xeb, 0xc0, 0x06, 0xaf, 0x9f, 0x0d, 0x11, 0x02,
  0x3c, 0x15, 0x7c, 0x77, 0x18, 0x5e, 0x0f, 0x87,
  0x9a, 0x09, 0xe6, 0x06, 0xdc, 0xc1, 0x3d, 0x78,
  0xd2, 0xfe, 0xe8, 0xf6, 0x22, 0xf8, 0x3c, 0x04,
  0xd1, 0xa4, 0xa9, 0xd3, 0x0c, 0x9b, 0x9b, 0x89,
  0x59, 0x28, 0xbf, 0x03, 0x6d, 0x39, 0xb2, 0x71,
  0x0f, 0x22, 0x6c, 0x44, 0xd9, 0x81, 0xed, 0x8c,
  0x25, 0x52, 0xd7, 0x00, 0xad, 0xe1, 0x88, 0xd0,
  0x97, 0x58, 0x5a, 0xca, 0x5a, 0x69, 0xe0, 0x5c,
  0x13, 0x9c, 0xb3, 0xa0, 0x4b, 0x47, 0xe1, 0xdd,
  0xcd, 0x41, 0xf0, 0xf6, 0x40, 0x78, 0xfb, 0x1c,
  0xfc, 0xbe, 0x06, 0x81, 0xde, 0x42, 0xf9, 0x83,
  0xa2, 0xbc, 0xda, 0x46, 0xe0, 0xe8, 0x20, 0x51,
  0xbe, 0x1e, 0x6d, 0xce, 0xd7, 0x8c, 0x25, 0x51,
  0x4e, 0x18, 0x8b, 0x07, 0xd2, 0xcb, 0xd9, 0xe0,
  0x14, 0xd2, 0xca, 0xb0, 0x25, 0x9d, 0x35, 0x5d,
  0x7e, 0x20, 0x0d, 0x1c, 0x7b, 0x84, 0xa7, 0x99,
  0xa1, 0xe1, 0x18, 0xd1, 0xc8, 0xcb, 0xd8, 0x8e,
  0x94, 0xd9, 0xeb, 0x9c, 0xb2, 0x7d, 0x27, 0xea,
  0xdd, 0x27, 0x6c, 0x28, 0xbb, 0x95, 0x38, 0x4c,
  0x5c, 0xe5, 0xf7, 0x32, 0xd3, 0xb7, 0xd8, 0xcb,
  0xf3, 0xba, 0x28, 0xdf, 0x88, 0x36, 0xb3, 0x34,
  0x63, 0x49, 0x86, 0x13, 0x2c, 0xe8, 0x95, 0x91,
  0x84, 0x9f, 0x3a, 0xf8, 0xde, 0x18, 0x4c, 0x96,
  0x12, 0x3b, 0x89, 0x22, 0x21, 0xc0, 0xea, 0xe5,
  0xe9, 0xac, 0xb1, 0xee, 0x81, 0x34, 0x1a, 0x01,
  0x1c, 0xa1, 0x08, 0x50, 0x72, 0xb8, 0xcc, 0x5e,
  0x27, 0x22, 0xa4, 0x45, 0x0f, 0x10, 0xe5, 0xaa,
  0x31, 0x36, 0x9c, 0x13, 0xbd, 0x45, 0x94, 0xe7,
  0x75, 0x55, 0x02, 0xd4, 0x68, 0x28, 0x6f, 0x83,
  0x62, 0xbc, 0x9a, 0xa9, 0x18, 0x60, 0xed, 0x22,
  0x3c, 0x8f, 0xc1, 0x84, 0x0f, 0x2a, 0x95, 0x44,
  0x03, 0xf1, 0x50, 0x11, 0x60, 0x59, 0x3a, 0xbb,
  0x7b, 0xe1, 0x2f, 0x69, 0x54, 0xdd, 0xfb, 0x91,
  0x13, 0x94, 0xfb, 0x25, 0x87, 0xca, 0xec, 0x75,
  0xc2, 0x27, 0x44, 0x3a, 0xaa, 0xd7, 0xea, 0xbd,
  0x17, 0xe5, 0x79, 0xdd, 0x76, 0xc6, 0x20, 0x67,
  0xb6, 0xf9, 0xab, 0x79, 0x06, 0xaf, 0x59, 0x2a,
  0x7a, 0x82, 0x72, 0xc5, 0x10, 0x6b, 0xa1, 0xd0,
  0x3d, 0x75, 0x63, 0xab, 0x92, 0xd6, 0xb0, 0x86,
  0x9f, 0x9a, 0xa5, 0x91, 0x19, 0x24, 0x7d, 0xfa,
  0xf9, 0xb0, 0xf2, 0xa2, 0x6f, 0xed, 0x75, 0xc2,
  0xc7, 0x47, 0xb6, 0x2a, 0x13, 0x30, 0x32, 0x48,
  0xf9, 0x5f, 0x8d, 0x28, 0xcf, 0xeb, 0x6a, 0xef,
  0x09, 0x24, 0x07, 0x69, 0x2e, 0xc2, 0x36, 0x62,
  0x1a, 0xe1, 0xcd, 0x05, 0x88, 0x27, 0xf6, 0x11,
  0x17, 0x14, 0xe3, 0x23, 0x82, 0x58, 0x5d, 0xc5,
  0x75, 0x76, 0xbb, 0xb6, 0xb9, 0x4b, 0xb1, 0x68,
  0x4e, 0x92, 0x10, 0xe0, 0x22, 0xf1, 0x21, 0xf1,
  0x26, 0xf1, 0x2c, 0x17, 0x20, 0x91, 0xc8, 0x27,
  0x6e, 0xf0, 0x02, 0x3b, 0x32, 0xf6, 0xb1, 0x9b,
  0x67, 0xfe, 0xec, 0x72, 0x1c, 0xdc, 0x9a, 0x2f,
  0x04, 0xb8, 0x43, 0x14, 0x12, 0x49, 0x62, 0x0d,
  0x91, 0xac, 0x1e, 0xa1, 0x8b, 0xf6, 0x94, 0xb2,
  0x1b, 0x55, 0xf7, 0xbb, 0x1c, 0x3c, 0x2e, 0xcd,
  0xec, 0xc1, 0xe3, 0x1e, 0xd3, 0x4a, 0x80, 0xc2,
  0x9d, 0xa5, 0xec, 0xb7, 0x53, 0x7f, 0x74, 0x3a,
  0xdc, 0xee, 0xf6, 0xb4, 0x6c, 0xb6, 0x62, 0xc1,
  0x3b, 0x0a, 0xfc, 0xf7, 0xf9, 0x4f, 0xaf, 0x7a,
  0xb4, 0x7d, 0x67, 0x02, 0x2c, 0x54, 0xcf, 0xb9,
  0xeb, 0x96, 0x6c, 0x62, 0x57, 0x4e, 0xde, 0xeb,
  0x14, 0xce, 0x7d, 0x72, 0x85, 0xa5, 0xce, 0x4f,
  0x63, 0x66, 0xbf, 0xa1, 0x4e, 0x07, 0xad, 0x49,
  0xe1, 0x53, 0xd8, 0x47, 0xdb, 0x8f, 0x77, 0xd8,
  0x16, 0x6f, 0xc3, 0x99, 0x00, 0x2d, 0x16, 0x3f,
  0x29, 0x73, 0xd3, 0x58, 0x7d, 0x59, 0x93, 0xee,
  0xe4, 0x6f, 0xb1, 0x31, 0x6f, 0x2f, 0x1f, 0x75,
  0xb0, 0x4d, 0x18, 0x87, 0xc4, 0x9a, 0xbf, 0x51,
  0x4c, 0xc7, 0x9c, 0xb8, 0x89, 0xb3, 0x3b, 0x6c,
  0x4f, 0x4a, 0x00, 0xcb, 0x9c, 0xd5, 0xec, 0xb2,
  0xad, 0x51, 0x57, 0xb6, 0x58, 0x76, 0xab, 0x03,
  0x6f, 0x50, 0x6d, 0x70, 0xf2, 0xe1, 0x4b, 0x0e,
  0x9c, 0xac, 0x80, 0x5f, 0xff, 0xf0, 0xb2, 0x21,
  0x81, 0x11, 0x6e, 0xdb, 0x3c, 0x92, 0x59, 0x22,
  0x27, 0x40, 0x72, 0xfc, 0x6a, 0x76, 0xf1, 0xe8,
  0x5d, 0xdd, 0x28, 0xd9, 0xf6, 0x35, 0xf3, 0xee,
  0xeb, 0xa3, 0x5e, 0xcf, 0x17, 0x61, 0x05, 0x6a,
  0xc5, 0x8c, 0x24, 0xf6, 0xfd, 0xc9, 0xd8, 0xec,
  0xe4, 0x12, 0xa7, 0xc5, 0xe6, 0x6c, 0x66, 0xf4,
  0x1b, 0x6e, 0xd9, 0xcd, 0x7b, 0x4f, 0x52, 0x80,
  0x65, 0xb3, 0x56, 0xb1, 0x9f, 0x0b, 0x1a, 0x74,
  0x63, 0xc2, 0xe8, 0x70, 0xe1, 0xc8, 0x2d, 0xa2,
  0x00, 0x41, 0xce, 0xc5, 0x4e, 0x74, 0x24, 0xb2,
  0x3e, 0xc3, 0x89, 0xf1, 0xd8, 0x9c, 0x59, 0xb0,
  0x55, 0x3e, 0x2d, 0x7a, 0x42, 0xee, 0xba, 0x62,
  0x97, 0xed, 0xf2, 0x3a, 0x52, 0x02, 0x2c, 0x9d,
  0x69, 0x65, 0xe7, 0x73, 0xef, 0xe8, 0xc2, 0xae,
  0xe4, 0x43, 0xda, 0xed, 0xef, 0x76, 0x62, 0x36,
  0xe6, 0xe3, 0x27, 0xa8, 0x8c, 0x49, 0x0d, 0x5d,
  0xbe, 0xd8, 0xc9, 0x59, 0xd0, 0x13, 0x14, 0x1f,
  0x5f, 0x19, 0x17, 0xe3, 0xb2, 0xed, 0x9c, 0xb4,
  0x63, 0x72, 0x02, 0x24, 0x4d, 0xb7, 0xb2, 0x73,
  0x07, 0x6e, 0xeb, 0xc2, 0xf4, 0xf0, 0x78, 0xed,
  0x6a, 0x8c, 0x27, 0x40, 0x5e, 0xa4, 0x7b, 0x26,
  0x67, 0x40, 0x04, 0x91, 0x4f, 0xe0, 0x63, 0xc2,
  0xdf, 0xbc, 0x8d, 0x13, 0x9b, 0xcf, 0xba, 0x64,
  0xbb, 0x30, 0xe3, 0xa4, 0x76, 0xd7, 0xb9, 0x82,
  0xdb, 0x6e, 0x25, 0xc0, 0x92, 0xa9, 0x2b, 0xd9,
  0x0f, 0x7b, 0x6f, 0xe9, 0xc2, 0x08, 0x73, 0x80,
  0x70, 0xa2, 0x1a, 0x5b, 0x5e, 0x65, 0x3d, 0x4e,
  0xf7, 0x4c, 0x6d, 0x81, 0xd7, 0xa1, 0xc5, 0x7a,
  0xe5, 0x40, 0xca, 0xc7, 0x2e, 0xdb, 0x77, 0xb0,
  0x5d, 0x8f, 0x6a, 0x25, 0xc0, 0xe2, 0x98, 0x95,
  0xac, 0x66, 0xe7, 0x4d, 0x5d, 0x70, 0xe4, 0x00,
  0xfd, 0x6f, 0x6a, 0x0f, 0x8c, 0x09, 0x2d, 0x92,
  0x2a, 0xee, 0xf8, 0xe9, 0x4c, 0x80, 0x38, 0x62,
  0x97, 0xd8, 0x7b, 0x47, 0x05, 0x4c, 0x66, 0x67,
  0xb7, 0xdd, 0xd0, 0x05, 0x47, 0x0e, 0xd0, 0xff,
  0xa6, 0xf6, 0xc0, 0xc0, 0xd8, 0xe2, 0x41, 0x25,
  0x4e, 0x7a, 0xdb, 0x23, 0xf6, 0x4d, 0x48, 0x25,
  0x65, 0x21, 0xa1, 0xc0, 0xc6, 0xf9, 0x87, 0xb1,
  0xea, 0xcc, 0xeb, 0xba, 0xd0, 0xaf, 0xb7, 0xb7,
  0x70, 0x82, 0xbf, 0xcb, 0x1b, 0x88, 0x89, 0x44,
  0x4f, 0xba, 0x67, 0x6a, 0x0b, 0xcc, 0x0e, 0x2d,
  0x36, 0x6d, 0xeb, 0xe2, 0xb2, 0x5c, 0xb6, 0x2f,
  0x25, 0x40, 0xf0, 0xb0, 0x30, 0x56, 0xf5, 0xee,
  0x35, 0x5d, 0xe0, 0x6d, 0xc3, 0x09, 0xde, 0xdb,
  0x76, 0x63, 0x06, 0x30, 0xd3, 0x3d, 0x93, 0x33,
  0xf8, 0xec, 0xa0, 0xca, 0x12, 0xdb, 0x30, 0x88,
  0xb1, 0xdc, 0xc5, 0x65, 0x2e, 0xdb, 0x97, 0x12,
  0x60, 0xec, 0x73, 0x61, 0xac, 0x72, 0xcd, 0x55,
  0x5d, 0x58, 0x3e, 0x31, 0x43, 0xbb, 0x06, 0x10,
  0xe9, 0xf3, 0x81, 0x74, 0xdf, 0xe4, 0x08, 0x8c,
  0xd4, 0x73, 0xb1, 0x58, 0x52, 0x92, 0xb5, 0x83,
  0x7d, 0xcc, 0x6e, 0xd9, 0x97, 0x13, 0x60, 0x68,
  0x28, 0xab, 0xb0, 0x5e, 0xd1, 0x85, 0xc2, 0xc4,
  0x4a, 0xe6, 0xd5, 0xcb, 0x5b, 0x9d, 0x3e, 0xdf,
  0x8f, 0x5c, 0x24, 0x17, 0x61, 0x28, 0xd1, 0x87,
  0xca, 0x89, 0xcf, 0x66, 0xbe, 0x08, 0x7e, 0x36,
  0xd6, 0x0b, 0x45, 0x58, 0x36, 0xb3, 0x85, 0x11,
  0xa9, 0x6e, 0xd9, 0x97, 0x12, 0x60, 0x8c, 0x39,
  0x94, 0x7d, 0x93, 0xf2, 0xab, 0x6e, 0x2c, 0x08,
  0x4b, 0x51, 0x2f, 0x86, 0x2a, 0x21, 0x82, 0x15,
  0x4f, 0x39, 0x06, 0x4e, 0x45, 0xe3, 0xfb, 0xc0,
  0x22, 0x04, 0x5f, 0x80, 0x5e, 0xa3, 0x08, 0x58,
  0xba, 0xe4, 0x47, 0xb7, 0x6c, 0xcb, 0x09, 0x30,
  0x24, 0x94, 0x7d, 0xb5, 0xb4, 0x5e, 0x57, 0xb8,
  0x0d, 0x95, 0x08, 0xb5, 0x78, 0xba, 0x3c, 0x2d,
  0xb7, 0x09, 0x8e, 0x89, 0xcf, 0x66, 0x79, 0x70,
  0xd6, 0x1e, 0xfc, 0xfe, 0xf8, 0x52, 0xb7, 0xed,
  0x4a, 0x09, 0xf0, 0xc2, 0x33, 0xa1, 0xec, 0xcb,
  0xc4, 0x5f, 0x74, 0xa5, 0x38, 0xa1, 0x56, 0xb1,
  0xa3, 0xd9, 0x11, 0xf2, 0x9c, 0x64, 0x95, 0x2a,
  0x8d, 0x5d, 0x83, 0x54, 0xb9, 0xb2, 0x09, 0xf2,
  0xea, 0xe9, 0xcd, 0xde, 0x9f, 0x76, 0xa4, 0x43,
  0x76, 0xfd, 0xfa, 0x99, 0x85, 0xbd, 0x2a, 0x88,
  0x3d, 0xb9, 0xb5, 0x00, 0x83, 0x43, 0xd8, 0xe7,
  0x0b, 0x2f, 0x77, 0x0a, 0xf3, 0x82, 0x2d, 0x4a,
  0x60, 0x0e, 0xd2, 0xda, 0x2d, 0xfe, 0xe3, 0x3e,
  0xed, 0x9d, 0x61, 0xeb, 0xb0, 0x3d, 0xde, 0x0e,
  0xda, 0xac, 0x41, 0xcc, 0x3c, 0x76, 0x45, 0x85,
  0x4d, 0x50, 0x85, 0x0d, 0xf2, 0x32, 0xb3, 0x13,
  0xf3, 0x2e, 0x75, 0x1a, 0x47, 0xe3, 0xbf, 0x67,
  0x2b, 0xc2, 0x37, 0xb3, 0x20, 0xbf, 0x10, 0xc5,
  0xb6, 0x08, 0x9a, 0xff, 0x8e, 0x1d, 0x95, 0xc0,
  0xb2, 0xa7, 0xda, 0x3c, 0x66, 0x8b, 0xb7, 0xe9,
  0x48, 0x80, 0x28, 0xbc, 0x0f, 0xe5, 0x42, 0xfd,
  0xcf, 0xe6, 0x5c, 0xea, 0x92, 0x04, 0x0d, 0x92,
  0x14, 0xa0, 0xf4, 0xf5, 0x8b, 0x5d, 0x92, 0x40,
  0x5f, 0x49, 0x01, 0x8e, 0xc7, 0xd5, 0x75, 0x49,
  0x02, 0x9f, 0x96, 0x14, 0xc0, 0x16, 0x5b, 0xf7,
  0xbf, 0xa0, 0x60, 0xea, 0x59, 0x96, 0x19, 0x79,
  0x58, 0x1a, 0xdf, 0x3e, 0x43, 0x1c, 0xce, 0x02,
  0x63, 0x91, 0x71, 0x29, 0x16, 0x07, 0x17, 0xfc,
  0x7d, 0x46, 0xb1, 0xc0, 0xa7, 0x26, 0x78, 0x8c,
  0xbe, 0x4f, 0x7a, 0x33, 0x37, 0x0f, 0x5b, 0xe8,
  0xc1, 0xef, 0x58, 0x77, 0xf0, 0x98, 0xc3, 0x4c,
  0x38, 0x34, 0x90, 0x80, 0x4f, 0xc7, 0xa7, 0xb5,
  0x1f, 0x48, 0x3d, 0xc8, 0x23, 0x1d, 0x78, 0x88,
  0x04, 0x89, 0x2c, 0x22, 0x09, 0xfb, 0x01, 0x31,
  0x0f, 0xcb, 0x6f, 0xe5, 0xc4, 0x44, 0x38, 0x14,
  0xc9, 0x46, 0x4f, 0xa8, 0x76, 0xf0, 0xed, 0xbd,
  0x23, 0x54, 0xb4, 0xf3, 0xed, 0xde, 0x5d, 0xbe,
  0x40, 0x96, 0x48, 0x96, 0x1c, 0xa4, 0xd6, 0x78,
  0xf0, 0xa1, 0x44, 0x0f, 0xf1, 0x89, 0xdc, 0x17,
  0x87, 0x24, 0xf8, 0x39, 0x81, 0x14, 0xa4, 0xab,
  0xb2, 0x3c, 0xc8, 0x86, 0x36, 0x4e, 0x6e, 0x74,
  0x84, 0x35, 0x48, 0x95, 0xc9, 0x22, 0x8e, 0xd9,
  0x05, 0xa8, 0x83, 0x57, 0x9f, 0x14, 0xf1, 0x87,
  0x10, 0x53, 0x54, 0xe7, 0x6e, 0x3c, 0xc1, 0xab,
  0x6d, 0x9c, 0xdd, 0xe9, 0x08, 0x11, 0xc8, 0xec,
  0xca, 0x32, 0x1c, 0xc7, 0x81, 0xa4, 0xce, 0x0b,
  0xf6, 0xf7, 0x20, 0x3d, 0x4c, 0xff, 0xd5, 0xcb,
  0x38, 0x2c, 0x6d, 0x08, 0x60, 0x08, 0x60, 0x08,
  0x60, 0x08, 0x60, 0x08, 0x60, 0x08, 0xf0, 0xd8,
  0xf2, 0x2f, 0x05, 0x04, 0x78, 0xfb, 0x38, 0x6e,
  0x64, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45,
  0x4e, 0x44, 0xae, 0x42, 0x60, 0x82
};

static const char track_none[] = {
  0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a,
  0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52,
  0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40,
  0x08, 0x06, 0x00, 0x00, 0x00, 0xaa, 0x69, 0x71,
  0xde, 0x00, 0x00, 0x00, 0x04, 0x73, 0x42, 0x49,
  0x54, 0x08, 0x08, 0x08, 0x08, 0x7c, 0x08, 0x64,
  0x88, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59,
  0x73, 0x00, 0x00, 0x0b, 0x12, 0x00, 0x00, 0x0b,
  0x12, 0x01, 0xd2, 0xdd, 0x7e, 0xfc, 0x00, 0x00,
  0x00, 0x1c, 0x74, 0x45, 0x58, 0x74, 0x53, 0x6f,
  0x66, 0x74, 0x77, 0x61, 0x72, 0x65, 0x00, 0x41,
  0x64, 0x6f, 0x62, 0x65, 0x20, 0x46, 0x69, 0x72,
  0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x20, 0x43,
  0x53, 0x33, 0x98, 0xd6, 0x46, 0x03, 0x00, 0x00,
  0x00, 0x16, 0x74, 0x45, 0x58, 0x74, 0x43, 0x72,
  0x65, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x54,
  0x69, 0x6d, 0x65, 0x00, 0x31, 0x32, 0x2f, 0x32,
  0x30, 0x2f, 0x30, 0x37, 0xa1, 0x4c, 0x30, 0x14,
  0x00, 0x00, 0x04, 0x11, 0x74, 0x45, 0x58, 0x74,
  0x58, 0x4d, 0x4c, 0x3a, 0x63, 0x6f, 0x6d, 0x2e,
  0x61, 0x64, 0x6f, 0x62, 0x65, 0x2e, 0x78, 0x6d,
  0x70, 0x00, 0x3c, 0x3f, 0x78, 0x70, 0x61, 0x63,
  0x6b, 0x65, 0x74, 0x20, 0x62, 0x65, 0x67, 0x69,
  0x6e, 0x3d, 0x22, 0x20, 0x20, 0x20, 0x22, 0x20,
  0x69, 0x64, 0x3d, 0x22, 0x57, 0x35, 0x4d, 0x30,
  0x4d, 0x70, 0x43, 0x65, 0x68, 0x69, 0x48, 0x7a,
  0x72, 0x65, 0x53, 0x7a, 0x4e, 0x54, 0x63, 0x7a,
  0x6b, 0x63, 0x39, 0x64, 0x22, 0x3f, 0x3e, 0x0a,
  0x3c, 0x78, 0x3a, 0x78, 0x6d, 0x70, 0x6d, 0x65,
  0x74, 0x61, 0x20, 0x78, 0x6d, 0x6c, 0x6e, 0x73,
  0x3a, 0x78, 0x3d, 0x22, 0x61, 0x64, 0x6f, 0x62,
  0x65, 0x3a, 0x6e, 0x73, 0x3a, 0x6d, 0x65, 0x74,
  0x61, 0x2f, 0x22, 0x20, 0x78, 0x3a, 0x78, 0x6d,
  0x70, 0x74, 0x6b, 0x3d, 0x22, 0x41, 0x64, 0x6f,
  0x62, 0x65, 0x20, 0x58, 0x4d, 0x50, 0x20, 0x43,
  0x6f, 0x72, 0x65, 0x20, 0x34, 0x2e, 0x31, 0x2d,
  0x63, 0x30, 0x33, 0x34, 0x20, 0x34, 0x36, 0x2e,
  0x32, 0x37, 0x32, 0x39, 0x37, 0x36, 0x2c, 0x20,
  0x53, 0x61, 0x74, 0x20, 0x4a, 0x61, 0x6e, 0x20,
  0x32, 0x37, 0x20, 0x32, 0x30, 0x30, 0x37, 0x20,
  0x32, 0x32, 0x3a, 0x31, 0x31, 0x3a, 0x34, 0x31,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x22, 0x3e, 0x0a, 0x20, 0x20, 0x20, 0x3c, 0x72,
  0x64, 0x66, 0x3a, 0x52, 0x44, 0x46, 0x20, 0x78,
  0x6d, 0x6c, 0x6e, 0x73, 0x3a, 0x72, 0x64, 0x66,
  0x3d, 0x22, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f,
  0x2f, 0x77, 0x77, 0x77, 0x2e, 0x77, 0x33, 0x2e,
  0x6f, 0x72, 0x67, 0x2f, 0x31, 0x39, 0x39, 0x39,
  0x2f, 0x30, 0x32, 0x2f, 0x32, 0x32, 0x2d, 0x72,
  0x64, 0x66, 0x2d, 0x73, 0x79, 0x6e, 0x74, 0x61,
  0x78, 0x2d, 0x6e, 0x73, 0x23, 0x22, 0x3e, 0x0a,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3c, 0x72,
  0x64, 0x66, 0x3a, 0x44, 0x65, 0x73, 0x63, 0x72,
  0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x72,
  0x64, 0x66, 0x3a, 0x61, 0x62, 0x6f, 0x75, 0x74,
  0x3d, 0x22, 0x22, 0x0a, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x78, 0x6d, 0x6c, 0x6e, 0x73, 0x3a, 0x78, 0x61,
  0x70, 0x3d, 0x22, 0x68, 0x74, 0x74, 0x70, 0x3a,
  0x2f, 0x2f, 0x6e, 0x73, 0x2e, 0x61, 0x64, 0x6f,
  0x62, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x78,
  0x61, 0x70, 0x2f, 0x31, 0x2e, 0x30, 0x2f, 0x22,
  0x3e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x3c, 0x78, 0x61, 0x70, 0x3a,
  0x43, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x54,
  0x6f, 0x6f, 0x6c, 0x3e, 0x41, 0x64, 0x6f, 0x62,
  0x65, 0x20, 0x46, 0x69, 0x72, 0x65, 0x77, 0x6f,
  0x72, 0x6b, 0x73, 0x20, 0x43, 0x53, 0x33, 0x3c,
  0x2f, 0x78, 0x61, 0x70, 0x3a, 0x43, 0x72, 0x65,
  0x61, 0x74, 0x6f, 0x72, 0x54, 0x6f, 0x6f, 0x6c,
  0x3e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x3c, 0x78, 0x61, 0x70, 0x3a,
  0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x44, 0x61,
  0x74, 0x65, 0x3e, 0x32, 0x30, 0x30, 0x37, 0x2d,
  0x31, 0x32, 0x2d, 0x32, 0x30, 0x54, 0x32, 0x31,
  0x3a, 0x30, 0x37, 0x3a, 0x31, 0x33, 0x5a, 0x3c,
  0x2f, 0x78, 0x61, 0x70, 0x3a, 0x43, 0x72, 0x65,
  0x61, 0x74, 0x65, 0x44, 0x61, 0x74, 0x65, 0x3e,
  0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x3c, 0x78, 0x61, 0x70, 0x3a, 0x4d,
  0x6f, 0x64, 0x69, 0x66, 0x79, 0x44, 0x61, 0x74,
  0x65, 0x3e, 0x32, 0x30, 0x30, 0x37, 0x2d, 0x31,
  0x32, 0x2d, 0x32, 0x30, 0x54, 0x32, 0x31, 0x3a,
  0x32, 0x35, 0x3a, 0x35, 0x39, 0x5a, 0x3c, 0x2f,
  0x78, 0x61, 0x70, 0x3a, 0x4d, 0x6f, 0x64, 0x69,
  0x66, 0x79, 0x44, 0x61, 0x74, 0x65, 0x3e, 0x0a,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3c, 0x2f,
  0x72, 0x64, 0x66, 0x3a, 0x44, 0x65, 0x73, 0x63,
  0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x3e,
  0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3c,
  0x72, 0x64, 0x66, 0x3a, 0x44, 0x65, 0x73, 0x63,
  0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x20,
  0x72, 0x64, 0x66, 0x3a, 0x61, 0x62, 0x6f, 0x75,
  0x74, 0x3d, 0x22, 0x22, 0x0a, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x78, 0x6d, 0x6c, 0x6e, 0x73, 0x3a, 0x64,
  0x63, 0x3d, 0x22, 0x68, 0x74, 0x74, 0x70, 0x3a,
  0x2f, 0x2f, 0x70, 0x75, 0x72, 0x6c, 0x2e, 0x6f,
  0x72, 0x67, 0x2f, 0x64, 0x63, 0x2f, 0x65, 0x6c,
  0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x2f, 0x31,
  0x2e, 0x31, 0x2f, 0x22, 0x3e, 0x0a, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3c,
  0x64, 0x63, 0x3a, 0x66, 0x6f, 0x72, 0x6d, 0x61,
  0x74, 0x3e, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x2f,
  0x70, 0x6e, 0x67, 0x3c, 0x2f, 0x64, 0x63, 0x3a,
  0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x3e, 0x0a,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3c, 0x2f,
  0x72, 0x64, 0x66, 0x3a, 0x44, 0x65, 0x73, 0x63,
  0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x3e,
  0x0a, 0x20, 0x20, 0x20, 0x3c, 0x2f, 0x72, 0x64,
  0x66, 0x3a, 0x52, 0x44, 0x46, 0x3e, 0x0a, 0x3c,
  0x2f, 0x78, 0x3a, 0x78, 0x6d, 0x70, 0x6d, 0x65,
  0x74, 0x61, 0x3e, 0x0a, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x0a, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x7d, 0x17, 0xed, 0x37, 0x00, 0x00, 0x02,
  0x5d, 0x49, 0x44, 0x41, 0x54, 0x78, 0xda, 0xed,
  0x9b, 0xcb, 0x8a, 0xd4, 0x40, 0x14, 0x86, 0xbf,
  0xb2, 0x93, 0x99, 0x8e, 0x3a, 0x17, 0x5c, 0x3b,
  0x38, 0x32, 0x8f, 0xe0, 0xca, 0xc5, 0x80, 0x8f,
  0x20, 0xbe, 0x84, 0x0f, 0xe4, 0x66, 0xde, 0xc2,
  0x87, 0x98, 0x85, 0x0b, 0x77, 0x03, 0x32, 0x1b,
  0x91, 0x6e, 0x10, 0xdc, 0xa8, 0x48, 0x2b, 0xb9,
  0x74, 0xd2, 0x29, 0x17, 0x39, 0x45, 0x87, 0x01,
  0x47, 0xe8, 0xa4, 0x92, 0x0e, 0x75, 0x0a, 0x42,
  0x2e, 0xd0, 0x55, 0xa9, 0xaf, 0xce, 0x7f, 0xaa,
  0x92, 0x3f, 0x6d, 0xac, 0xb5, 0x84, 0x5c, 0x1e,
  0x10, 0x78, 0x51, 0x00, 0x0a, 0x40, 0x01, 0x28,
  0x00, 0x05, 0xa0, 0x00, 0x14, 0x80, 0x02, 0x50,
  0x00, 0x0a, 0x40, 0x01, 0x28, 0x00, 0x05, 0x10,
  0x62, 0x89, 0x76, 0xfd, 0xa1, 0x31, 0xa6, 0x0d,
  0x31, 0x06, 0x0e, 0x81, 0x99, 0x9c, 0x1b, 0x4f,
  0xf7, 0x6b, 0x81, 0x1a, 0xd8, 0x00, 0x05, 0x50,
  0xca, 0x39, 0xbb, 0xbe, 0xd7, 0x88, 0x7a, 0x00,
  0x98, 0x00, 0x73, 0xd9, 0x1f, 0x08, 0x04, 0x9f,
  0x00, 0x36, 0xc0, 0x1a, 0xc8, 0x80, 0x5c, 0xf6,
  0xd5, 0xe0, 0x11, 0x20, 0x23, 0x3d, 0x07, 0x1e,
  0x03, 0xc7, 0xc0, 0x91, 0x40, 0x88, 0x3d, 0x4a,
  0xab, 0x96, 0x51, 0xcf, 0x80, 0xdf, 0xc0, 0x4a,
  0xa0, 0xa4, 0x2e, 0x12, 0x86, 0x04, 0x10, 0x4b,
  0x87, 0x8f, 0x81, 0x27, 0xc0, 0x69, 0x0b, 0x80,
  0xcf, 0x08, 0x70, 0x00, 0x62, 0xb9, 0x56, 0xc9,
  0xb5, 0x62, 0x68, 0x00, 0x07, 0x12, 0x01, 0x47,
  0xc0, 0x09, 0xf0, 0x02, 0xb8, 0x04, 0x9e, 0x01,
  0x0f, 0x3d, 0x01, 0xc8, 0x80, 0x25, 0x70, 0x0d,
  0x7c, 0x94, 0x8e, 0xa7, 0x22, 0x85, 0xc1, 0x01,
  0x44, 0x02, 0x21, 0x91, 0x0e, 0x5f, 0x02, 0xaf,
  0x5a, 0x23, 0xe3, 0xab, 0x9c, 0xcb, 0xfe, 0x53,
  0x2b, 0xef, 0x44, 0x63, 0xe5, 0x80, 0x99, 0x74,
  0x38, 0x92, 0x91, 0x8f, 0x9b, 0x09, 0xc2, 0x8f,
  0x02, 0x24, 0xd3, 0xc7, 0x02, 0x21, 0x92, 0xe3,
  0x59, 0x97, 0x9c, 0xd3, 0x05, 0x80, 0x91, 0x86,
  0xdd, 0x96, 0xb8, 0xe9, 0x71, 0x9e, 0x3c, 0xe2,
  0xec, 0xf9, 0x45, 0xaf, 0x9d, 0xff, 0xba, 0xf8,
  0x42, 0x96, 0xfe, 0x71, 0x10, 0xe6, 0x77, 0xda,
  0x36, 0x63, 0x00, 0xf8, 0x67, 0x79, 0x7a, 0x7e,
  0xc1, 0xd5, 0xfb, 0x0f, 0xbd, 0xd6, 0xf9, 0xf6,
  0xf5, 0x4b, 0x3e, 0xdf, 0xde, 0xec, 0xcf, 0x42,
  0xe8, 0xde, 0xb9, 0xca, 0x42, 0x51, 0xd5, 0xbd,
  0xd7, 0xb9, 0x57, 0x2b, 0xc1, 0xff, 0x69, 0xb5,
  0x28, 0x6b, 0x1f, 0xfa, 0x9f, 0x52, 0x04, 0xd8,
  0x80, 0x23, 0x80, 0xfe, 0x25, 0xe0, 0xcb, 0xc1,
  0xf4, 0x24, 0x01, 0x28, 0x4a, 0xdb, 0x7b, 0x9d,
  0x13, 0x92, 0x80, 0xf5, 0x90, 0x04, 0xad, 0x46,
  0xc0, 0xa4, 0x00, 0xe4, 0x7d, 0xe7, 0x80, 0xa9,
  0x00, 0xb0, 0x12, 0xae, 0xeb, 0xb2, 0x7f, 0x09,
  0xd8, 0x49, 0x49, 0xa0, 0x0a, 0x59, 0x02, 0xa1,
  0x4f, 0x83, 0xb5, 0x87, 0x24, 0x38, 0xbd, 0xa5,
  0x70, 0x15, 0xf0, 0x52, 0x38, 0xf8, 0x1c, 0x50,
  0x5b, 0xc8, 0xcb, 0x5a, 0x25, 0x10, 0xf6, 0xd3,
  0x60, 0xa9, 0x4f, 0x83, 0xfa, 0x34, 0x18, 0x6c,
  0x12, 0xcc, 0xbe, 0x2f, 0xb8, 0x79, 0xf7, 0xa6,
  0xd7, 0x3a, 0xf3, 0x1f, 0x8b, 0xbd, 0x03, 0xe0,
  0x8c, 0x4a, 0xb7, 0xe5, 0x6e, 0xa8, 0xea, 0x75,
  0x46, 0xfa, 0xed, 0xd6, 0x93, 0xb8, 0x1a, 0xc6,
  0x77, 0xda, 0xb6, 0x63, 0x00, 0x70, 0x2e, 0x6d,
  0x49, 0x63, 0x4f, 0x2d, 0x69, 0xde, 0xd7, 0xc7,
  0xfe, 0x14, 0x0b, 0xd2, 0xde, 0x92, 0xad, 0x25,
  0xb6, 0x61, 0x47, 0x5f, 0xb0, 0x2b, 0x80, 0x8a,
  0xad, 0x4b, 0x9b, 0xd2, 0xd8, 0x55, 0xd0, 0x18,
  0x24, 0x89, 0xa7, 0xce, 0xe7, 0xc0, 0x42, 0xda,
  0x4a, 0xa5, 0xed, 0x35, 0x1d, 0xdc, 0x61, 0xb3,
  0xeb, 0xfc, 0x6a, 0x8c, 0x39, 0x64, 0x6b, 0x8c,
  0x8e, 0x61, 0x8e, 0xfe, 0x02, 0x7e, 0xca, 0xb6,
  0xb2, 0xd6, 0x0e, 0xee, 0x0d, 0xba, 0x1b, 0x59,
  0xb5, 0xce, 0xc7, 0xb0, 0xc7, 0x33, 0xb9, 0x36,
  0x4a, 0x0e, 0xc8, 0x65, 0xb4, 0x2b, 0xb9, 0x91,
  0x31, 0x3e, 0x90, 0xc8, 0xbb, 0xe4, 0x80, 0x2e,
  0x12, 0x70, 0x87, 0x93, 0xfe, 0x44, 0xc6, 0xe8,
  0x7f, 0x86, 0x02, 0x2f, 0x0a, 0x40, 0x01, 0x28,
  0x00, 0x05, 0xa0, 0x00, 0x14, 0x80, 0x02, 0x50,
  0x00, 0x0a, 0x20, 0xd4, 0xf2, 0x17, 0xfb, 0x90,
  0x2b, 0x17, 0x61, 0x25, 0x94, 0x28, 0x00, 0x00,
  0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42,
  0x60, 0x82
};

static const char video_camera[] = {
  0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a,
  0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52,
  0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40,
  0x08, 0x06, 0x00, 0x00, 0x00, 0xaa, 0x69, 0x71,
  0xde, 0x00, 0x00, 0x0f, 0xc7, 0x49, 0x44, 0x41,
  0x54, 0x78, 0x9c, 0xcd, 0x9b, 0x59, 0x6c, 0x1d,
  0xd7, 0x79, 0xc7, 0x7f, 0x67, 0xee, 0x46, 0xf1,
  0x72, 0xb9, 0x12, 0x23, 0x91, 0x94, 0x64, 0x8b,
  0xb6, 0x2c, 0x83, 0xb6, 0x14, 0xc5, 0x96, 0xeb,
  0xd4, 0xf5, 0xd2, 0x02, 0xa9, 0x11, 0xa8, 0x08,
  0x8c, 0xba, 0x01, 0xda, 0xd4, 0x7d, 0xe8, 0x63,
  0x0a, 0xb8, 0x29, 0x90, 0x3c, 0xf6, 0xd1, 0x0f,
  0x0d, 0xfa, 0xe6, 0x34, 0x79, 0x32, 0x8a, 0xba,
  0x2f, 0x6d, 0x0c, 0x14, 0x68, 0x81, 0xb4, 0xe9,
  0x96, 0xb8, 0x45, 0xda, 0xc0, 0x36, 0x1a, 0x4b,
  0x5e, 0x44, 0x2f, 0xb2, 0xac, 0x85, 0x32, 0x44,
  0x51, 0x94, 0x44, 0x91, 0xe2, 0x26, 0xde, 0x6d,
  0xbe, 0x3e, 0x9c, 0x7d, 0x66, 0x2e, 0x2f, 0xe9,
  0xa0, 0xb5, 0x0f, 0x30, 0xf7, 0xce, 0x9c, 0x99,
  0x39, 0xe7, 0xfc, 0xbf, 0xef, 0xff, 0x7d, 0xdf,
  0xd9, 0x46, 0xb1, 0xbd, 0xa4, 0xcc, 0x91, 0xcd,
  0xfb, 0x3c, 0x25, 0x29, 0xb8, 0xce, 0xe6, 0xe5,
  0xd2, 0x56, 0x20, 0xca, 0x40, 0x1d, 0x18, 0x06,
  0x86, 0x80, 0x01, 0xa0, 0x02, 0x94, 0xf0, 0x02,
  0xf9, 0xac, 0x84, 0x52, 0x04, 0x16, 0x20, 0x35,
  0x47, 0x1b, 0x68, 0x02, 0x6b, 0xc0, 0xaa, 0xf9,
  0x6f, 0x17, 0x15, 0xd4, 0xab, 0xc1, 0xc3, 0xc0,
  0x41, 0x60, 0x1f, 0xb0, 0x07, 0x68, 0xa0, 0x85,
  0x50, 0x43, 0x0b, 0x21, 0x31, 0x87, 0x7d, 0xff,
  0xb3, 0x62, 0x83, 0x04, 0xff, 0x82, 0x06, 0xdf,
  0x41, 0x83, 0xdf, 0x00, 0x96, 0xcc, 0x71, 0x03,
  0xb8, 0x62, 0xce, 0x23, 0xe1, 0x95, 0x33, 0x05,
  0x26, 0xc0, 0x18, 0x30, 0x05, 0xdc, 0x07, 0x3c,
  0x40, 0x52, 0x3a, 0x4a, 0x6d, 0xf0, 0x20, 0x89,
  0xaa, 0x93, 0x65, 0x80, 0x2e, 0xea, 0xb3, 0x36,
  0x05, 0xdb, 0x8a, 0x50, 0x08, 0x6d, 0x52, 0xd9,
  0xa0, 0xb9, 0x31, 0x4f, 0xda, 0x3d, 0x0b, 0x7c,
  0x00, 0x8c, 0x00, 0x17, 0x81, 0x6b, 0xe6, 0x19,
  0x20, 0x2f, 0x80, 0x31, 0xe0, 0x08, 0x70, 0x9c,
  0x4a, 0xed, 0x24, 0x13, 0x53, 0x8f, 0x35, 0xbe,
  0xf8, 0xf8, 0xbe, 0xc6, 0xd4, 0xb4, 0x2a, 0x55,
  0xaa, 0x9e, 0xf3, 0x0a, 0x94, 0xc1, 0x1d, 0x52,
  0x40, 0x05, 0x19, 0xa1, 0x54, 0xb6, 0x6b, 0x27,
  0xbd, 0x78, 0x9d, 0x3b, 0x97, 0x38, 0xcf, 0x19,
  0xbb, 0x88, 0xcb, 0xeb, 0xb4, 0x5b, 0x2c, 0xcf,
  0x9e, 0x95, 0xe5, 0x99, 0xd7, 0x7f, 0x8d, 0x6b,
  0xb3, 0xa7, 0x69, 0x37, 0x7f, 0x12, 0xe0, 0x9d,
  0xb7, 0xaf, 0x84, 0x02, 0x18, 0x46, 0x6b, 0xfe,
  0x38, 0xf5, 0xd1, 0x6f, 0xd4, 0x7f, 0xe5, 0xe9,
  0x27, 0x8f, 0x3d, 0xf7, 0x9d, 0xf2, 0xe8, 0x81,
  0x7b, 0x34, 0x38, 0xe5, 0x39, 0xaf, 0x94, 0x0a,
  0xce, 0x03, 0x87, 0xa0, 0x42, 0xc7, 0xa0, 0xdc,
  0x75, 0x3f, 0x81, 0x6c, 0x05, 0x58, 0x1c, 0x60,
  0x71, 0x40, 0x45, 0x3c, 0xe8, 0xf0, 0x3a, 0x45,
  0xfc, 0xb9, 0xfe, 0x57, 0xb7, 0xe7, 0x2e, 0x7d,
  0xe1, 0xbd, 0x57, 0x5e, 0x7c, 0x7a, 0xfd, 0xd4,
  0xab, 0xa3, 0xac, 0xdf, 0x06, 0x68, 0x01, 0x77,
  0xd0, 0xe6, 0x40, 0xc9, 0xd4, 0x53, 0x06, 0xee,
  0x01, 0x1e, 0xa4, 0x52, 0x7b, 0xb6, 0xfe, 0xab,
  0xbf, 0xf5, 0xf4, 0xa3, 0xcf, 0x7f, 0xb7, 0x5c,
  0x1f, 0x1b, 0x47, 0x01, 0x09, 0x42, 0x62, 0xb4,
  0x9e, 0x80, 0x39, 0xd7, 0x47, 0xa2, 0x02, 0x87,
  0xa0, 0x94, 0xcf, 0x0f, 0xee, 0xd9, 0xeb, 0xd0,
  0x73, 0x66, 0xaf, 0x29, 0x38, 0x07, 0x50, 0x92,
  0x11, 0x98, 0x48, 0xfc, 0x5e, 0x20, 0x35, 0x15,
  0x50, 0x43, 0xdf, 0x57, 0xd4, 0x46, 0x76, 0x33,
  0xf1, 0xd0, 0x53, 0xc9, 0x8d, 0xb9, 0x4b, 0x93,
  0xed, 0xab, 0x17, 0x4b, 0xa4, 0xdd, 0x39, 0x60,
  0xdd, 0x08, 0x20, 0xb5, 0x0c, 0xa8, 0xa3, 0x1d,
  0xde, 0x03, 0x4c, 0x4c, 0x3d, 0x76, 0xec, 0xb9,
  0x6f, 0x97, 0xab, 0x83, 0x43, 0x28, 0xc4, 0x14,
  0x2a, 0x51, 0x43, 0xbc, 0xa6, 0x43, 0x9d, 0xa9,
  0x98, 0x01, 0x61, 0xab, 0x03, 0x6a, 0xda, 0x7b,
  0x22, 0xe1, 0xbb, 0xf6, 0x39, 0x3c, 0xbf, 0x5d,
  0x96, 0xe4, 0xb2, 0x45, 0xc4, 0x68, 0xd8, 0xdf,
  0x13, 0x11, 0x1d, 0x02, 0x1c, 0x3b, 0x04, 0x92,
  0x32, 0xaa, 0x52, 0xa5, 0x3a, 0x38, 0xc4, 0xb1,
  0xe7, 0xbe, 0x53, 0xfa, 0x9f, 0x0b, 0x33, 0x27,
  0xb8, 0x72, 0x6e, 0x06, 0xf8, 0x04, 0xcd, 0xf8,
  0x5b, 0x89, 0x29, 0x73, 0x18, 0xd8, 0x43, 0x52,
  0x3a, 0xda, 0xf8, 0xe2, 0xe3, 0xfb, 0x1c, 0xed,
  0x45, 0x50, 0x48, 0xa4, 0x45, 0xaf, 0x55, 0x71,
  0x52, 0x4e, 0x94, 0xf2, 0x4c, 0x50, 0xde, 0x5c,
  0xf4, 0x21, 0xfa, 0xda, 0x1d, 0x8a, 0x44, 0x20,
  0x41, 0x65, 0x0e, 0xfb, 0xbe, 0x0a, 0x9e, 0x8d,
  0xeb, 0xd5, 0x02, 0x16, 0xc7, 0x3c, 0x85, 0x72,
  0x8a, 0xb0, 0xc2, 0x0f, 0x59, 0x47, 0xb7, 0x0d,
  0xed, 0x26, 0x09, 0x30, 0x7a, 0xe0, 0x1e, 0x1a,
  0xc7, 0x9f, 0xd8, 0x43, 0x52, 0x7a, 0x10, 0xd8,
  0x6d, 0x30, 0xbb, 0x67, 0x87, 0x80, 0x06, 0xb5,
  0xc1, 0x83, 0x8d, 0xa9, 0x69, 0x65, 0x69, 0x9f,
  0x05, 0xaf, 0x32, 0xe0, 0x13, 0x94, 0x37, 0x87,
  0x00, 0x78, 0x29, 0x6a, 0x88, 0x07, 0x59, 0x52,
  0xca, 0x99, 0x53, 0x29, 0x3c, 0x4c, 0x3d, 0xa1,
  0x90, 0x22, 0x13, 0x53, 0x5e, 0x98, 0xa1, 0x12,
  0x7c, 0xbe, 0xf2, 0x82, 0x02, 0x94, 0x12, 0x67,
  0x92, 0x74, 0x3b, 0xae, 0xbd, 0x8d, 0xa9, 0x69,
  0x45, 0x6d, 0x70, 0xdc, 0x08, 0x60, 0x17, 0xa0,
  0xca, 0xa6, 0x9e, 0x01, 0x60, 0x88, 0x44, 0xd5,
  0x4b, 0x95, 0xaa, 0xa7, 0xb2, 0xf4, 0x06, 0xbf,
  0x3d, 0x47, 0x48, 0xec, 0x08, 0x03, 0x1e, 0x7b,
  0x0b, 0xd1, 0x34, 0x56, 0xee, 0x4a, 0xd7, 0x21,
  0xca, 0x52, 0x59, 0x21, 0xa2, 0x41, 0x85, 0xce,
  0x2f, 0x55, 0x90, 0x18, 0xd3, 0x12, 0xa5, 0x33,
  0x45, 0x41, 0x2a, 0x1a, 0xbc, 0xbe, 0x0f, 0xa9,
  0x11, 0x66, 0xa2, 0xa0, 0x5c, 0xad, 0x41, 0xa2,
  0x06, 0x0d, 0xf8, 0x8a, 0x15, 0x00, 0xe6, 0xa2,
  0x06, 0x54, 0xbc, 0x83, 0x52, 0x3d, 0xc1, 0x67,
  0x35, 0x14, 0x03, 0x57, 0xbe, 0x83, 0x10, 0x09,
  0x43, 0xd3, 0x34, 0x07, 0x5e, 0x70, 0xf9, 0x0e,
  0xbc, 0x11, 0xbe, 0xef, 0xcb, 0x8a, 0xf1, 0xf2,
  0x4a, 0xdf, 0x20, 0x06, 0x9f, 0x8a, 0x6e, 0x53,
  0x2a, 0x9a, 0x5d, 0xa9, 0xe0, 0x84, 0xa0, 0xc4,
  0xd7, 0x6b, 0x1c, 0x49, 0x19, 0xdf, 0x99, 0x73,
  0x61, 0xb0, 0x64, 0x32, 0x4b, 0xa1, 0x97, 0xb6,
  0x20, 0x0a, 0xc1, 0x87, 0x1e, 0x3e, 0x63, 0x8f,
  0x16, 0xa4, 0x67, 0x52, 0xd0, 0x63, 0xb2, 0x8c,
  0x10, 0xad, 0x5d, 0x95, 0x71, 0xe5, 0xce, 0x91,
  0x5b, 0x06, 0x88, 0x67, 0x88, 0x52, 0x90, 0x8a,
  0xf2, 0xce, 0x0f, 0xdd, 0xa3, 0x49, 0xac, 0xe6,
  0xcd, 0xfd, 0x44, 0x69, 0x27, 0xa9, 0x0c, 0x1b,
  0x9c, 0x30, 0xbc, 0xfc, 0x6d, 0xb6, 0x13, 0x40,
  0xa8, 0x78, 0x13, 0xce, 0xa4, 0x27, 0xf8, 0xd0,
  0x39, 0x29, 0x65, 0x1d, 0x61, 0x00, 0x34, 0x34,
  0x09, 0xa7, 0x79, 0xdb, 0x75, 0x0a, 0xb4, 0xec,
  0x60, 0x2b, 0xaf, 0x6b, 0x65, 0xf9, 0xe2, 0x29,
  0x8f, 0x32, 0x5d, 0x37, 0xc1, 0x81, 0xc3, 0xb0,
  0x21, 0x11, 0x1d, 0xff, 0x95, 0xb2, 0xf7, 0xb5,
  0x10, 0x6c, 0x9b, 0x3d, 0x38, 0xa5, 0x7d, 0x42,
  0x1c, 0x85, 0xb1, 0x3e, 0x20, 0xc0, 0x13, 0xd8,
  0x36, 0x5e, 0x3b, 0x2a, 0xd0, 0x7c, 0x6c, 0x1a,
  0x26, 0xfc, 0xd9, 0xf8, 0x1c, 0x81, 0x0f, 0x99,
  0x61, 0xdb, 0xac, 0xc1, 0x37, 0xbb, 0x1d, 0x9a,
  0x69, 0x17, 0x80, 0x5a, 0x52, 0x62, 0xa0, 0x54,
  0xd2, 0xe1, 0xd1, 0xb1, 0x43, 0x83, 0x56, 0x4a,
  0x21, 0x46, 0x93, 0x82, 0x0e, 0x75, 0x56, 0xa3,
  0x88, 0x16, 0x82, 0x92, 0x30, 0xcf, 0x2a, 0xcc,
  0x0b, 0xc5, 0x99, 0x80, 0x4f, 0x4e, 0x36, 0x21,
  0x03, 0x5c, 0x58, 0x8f, 0xb4, 0x87, 0x0d, 0x59,
  0x31, 0x77, 0x22, 0xf0, 0x51, 0x68, 0x32, 0x42,
  0x10, 0x22, 0x21, 0xae, 0x76, 0x9a, 0x1c, 0xde,
  0x5d, 0xe5, 0x70, 0xa3, 0xc6, 0x81, 0xe1, 0x0a,
  0x13, 0xf5, 0x2a, 0xbb, 0x07, 0x2a, 0x00, 0x2c,
  0x6d, 0xb6, 0xb9, 0xb6, 0xde, 0x62, 0x6e, 0xb5,
  0xc5, 0xf9, 0xa5, 0x26, 0x17, 0x96, 0x5a, 0x0c,
  0x97, 0x2a, 0x24, 0x4a, 0x3b, 0x40, 0x94, 0x42,
  0x49, 0x0c, 0x3e, 0x11, 0x2f, 0x10, 0x07, 0xd4,
  0xd4, 0xa5, 0xac, 0xc2, 0x44, 0xbc, 0xc9, 0x05,
  0xce, 0x38, 0x14, 0x42, 0x76, 0x2c, 0xa0, 0x42,
  0xfb, 0xc6, 0x6a, 0xd0, 0x6a, 0x3d, 0x00, 0xd8,
  0x1b, 0xbc, 0x22, 0x31, 0x6c, 0x10, 0x84, 0x52,
  0xb9, 0xcd, 0x6f, 0x1e, 0x1a, 0xe6, 0xab, 0x53,
  0xfb, 0xa9, 0x57, 0xb2, 0xd5, 0xe9, 0xb4, 0xbf,
  0x3e, 0xc0, 0xd1, 0x31, 0x7f, 0xbd, 0xde, 0xee,
  0xf0, 0x93, 0xd9, 0x5b, 0xbc, 0x3a, 0xbb, 0x42,
  0xbb, 0x5d, 0x32, 0xda, 0x0f, 0x1c, 0x1d, 0x31,
  0x1b, 0x40, 0x91, 0x2a, 0x21, 0x31, 0x42, 0xf2,
  0x94, 0x56, 0xa4, 0x26, 0x74, 0xba, 0xd1, 0x8f,
  0x04, 0x7a, 0xc9, 0x08, 0x40, 0x85, 0x27, 0xf6,
  0x22, 0xeb, 0xe5, 0x9d, 0xc3, 0x0b, 0xc1, 0xdb,
  0x0a, 0x8d, 0xef, 0x48, 0x14, 0x74, 0xa4, 0xcd,
  0x33, 0x47, 0x46, 0xf8, 0xda, 0xbd, 0x63, 0x24,
  0x05, 0x1c, 0xdc, 0x2a, 0xd5, 0x2b, 0x65, 0x7e,
  0xe7, 0xc8, 0x3e, 0x7e, 0xfb, 0xbe, 0xbd, 0xfc,
  0xf3, 0xc5, 0x9b, 0xfc, 0xe3, 0x47, 0xcb, 0x94,
  0x54, 0xd9, 0xb1, 0xc1, 0xf6, 0xfa, 0xac, 0xc7,
  0x57, 0x98, 0x90, 0x47, 0xa0, 0x20, 0xb1, 0x51,
  0x20, 0x36, 0xc9, 0x6c, 0xca, 0xa9, 0x24, 0x7e,
  0x38, 0xb6, 0xfb, 0xac, 0xc3, 0x8b, 0x1c, 0xa2,
  0xe9, 0xe4, 0x20, 0xc2, 0xd8, 0x90, 0xf0, 0xed,
  0x47, 0x0e, 0x32, 0xb6, 0xab, 0xba, 0x23, 0xe0,
  0xd9, 0x94, 0x28, 0xc5, 0x33, 0x87, 0xf7, 0xf2,
  0xf8, 0xfe, 0x51, 0xbe, 0x77, 0x6a, 0x8e, 0xeb,
  0x2b, 0x5e, 0x9b, 0x0e, 0xbc, 0xd2, 0x21, 0x51,
  0x83, 0xd5, 0x11, 0x00, 0x0b, 0x3e, 0xf5, 0xbd,
  0xd5, 0x5e, 0x3a, 0xf0, 0x4c, 0x0f, 0x05, 0x60,
  0x7e, 0xf2, 0x0e, 0x0d, 0x17, 0xd6, 0x8a, 0xc0,
  0xa7, 0x92, 0x72, 0x74, 0xbc, 0xc4, 0x0b, 0x4f,
  0xdc, 0xfd, 0x4b, 0x83, 0x0f, 0xd3, 0xd8, 0xae,
  0x2a, 0x2f, 0x3c, 0x39, 0xc5, 0xb1, 0xc9, 0x2a,
  0xa9, 0xc4, 0xa0, 0x92, 0x80, 0xd3, 0xe1, 0x20,
  0xcd, 0x39, 0x65, 0x03, 0xca, 0xe1, 0xea, 0x21,
  0x00, 0x9f, 0xb2, 0xa0, 0x55, 0x1c, 0xee, 0x72,
  0x9d, 0x1c, 0x43, 0x7b, 0x44, 0x78, 0x78, 0xa2,
  0xca, 0xb7, 0x1e, 0x3e, 0x10, 0x51, 0xfe, 0xa3,
  0xc5, 0x4d, 0xde, 0xbc, 0xba, 0x4e, 0x5a, 0x34,
  0xf8, 0xd9, 0x41, 0x4a, 0x94, 0xe2, 0x4f, 0x4e,
  0x1c, 0xe4, 0xc4, 0x81, 0x01, 0x08, 0x4c, 0x2f,
  0xdf, 0x66, 0xcb, 0xdd, 0x4c, 0xc4, 0xea, 0x55,
  0x6e, 0x51, 0x66, 0xd6, 0x66, 0xc2, 0xa8, 0x00,
  0x44, 0x26, 0x91, 0x18, 0xa7, 0x74, 0x77, 0x23,
  0xe1, 0x9b, 0x5f, 0x9a, 0xc8, 0x95, 0xf5, 0xc6,
  0x95, 0x55, 0xfe, 0xee, 0xfd, 0x5b, 0xfc, 0xe0,
  0x17, 0x0b, 0x5c, 0x5a, 0xda, 0xdc, 0x19, 0xea,
  0x82, 0xf4, 0x47, 0x0f, 0xed, 0xe7, 0xd0, 0x9e,
  0x32, 0x4a, 0xf9, 0xb6, 0x78, 0x05, 0x41, 0xe8,
  0xe5, 0x8a, 0x30, 0x64, 0x53, 0x4e, 0x00, 0xa1,
  0xed, 0x17, 0x85, 0x90, 0xd8, 0x14, 0xf4, 0x7f,
  0xad, 0x94, 0xf2, 0xfc, 0xc3, 0xe3, 0x85, 0xce,
  0xce, 0x0a, 0x6e, 0x6e, 0xa5, 0xc5, 0x4b, 0xa7,
  0x6e, 0xf0, 0xca, 0xcc, 0x4d, 0x96, 0x37, 0x3b,
  0x9f, 0x02, 0xba, 0x69, 0xb0, 0x52, 0x7c, 0xeb,
  0x91, 0xfd, 0xd4, 0xca, 0x01, 0x2b, 0x0b, 0xc0,
  0x47, 0x6d, 0x56, 0x9e, 0x19, 0xb9, 0xf2, 0x8a,
  0x32, 0xed, 0xc8, 0x2e, 0x04, 0xea, 0x26, 0x19,
  0x32, 0x26, 0x02, 0xc2, 0xd7, 0xa7, 0x1b, 0x8c,
  0xd6, 0x2a, 0x85, 0x15, 0x78, 0x1a, 0xea, 0x86,
  0xce, 0x2c, 0xdc, 0xe1, 0x7b, 0x6f, 0xcc, 0xf3,
  0x1f, 0x17, 0x97, 0x69, 0x75, 0xd3, 0xc2, 0x77,
  0xfa, 0xa5, 0xd1, 0x5a, 0x85, 0xdf, 0x3d, 0x3a,
  0x06, 0x62, 0x47, 0xab, 0xbe, 0xe7, 0x17, 0xb6,
  0xd1, 0xb5, 0x81, 0x62, 0xfb, 0x87, 0x6d, 0x98,
  0x40, 0xd1, 0xc0, 0x26, 0xac, 0x6c, 0xdf, 0x50,
  0xc2, 0x53, 0x07, 0x47, 0x7b, 0x36, 0x56, 0x49,
  0x30, 0xc6, 0x47, 0x3b, 0xad, 0x4e, 0x2a, 0xfc,
  0xec, 0xd2, 0x0a, 0xdf, 0x7f, 0x63, 0x9e, 0x33,
  0xd7, 0xd6, 0x8b, 0x27, 0x47, 0xfa, 0xa4, 0xa7,
  0x0e, 0x36, 0x98, 0x18, 0x29, 0xeb, 0x46, 0x84,
  0x63, 0x8d, 0x1e, 0x58, 0x7a, 0xdd, 0xef, 0x61,
  0x02, 0x26, 0x65, 0x66, 0x72, 0xb2, 0xde, 0x55,
  0x29, 0x38, 0x79, 0xef, 0xc8, 0x96, 0x0d, 0x0d,
  0x1d, 0x51, 0xa2, 0xfc, 0xf8, 0x22, 0x51, 0xb0,
  0xda, 0xea, 0xf2, 0xf7, 0xef, 0x2f, 0xf2, 0xf2,
  0xe9, 0x05, 0xae, 0xae, 0x34, 0xb7, 0x2c, 0xa7,
  0x28, 0x9d, 0x3c, 0xbc, 0x3b, 0x68, 0x8f, 0xf2,
  0xf5, 0x89, 0x64, 0x7a, 0xa2, 0x9f, 0xd2, 0x09,
  0x66, 0xcf, 0x09, 0xc4, 0xa1, 0x6d, 0x5f, 0x78,
  0x74, 0x62, 0xb8, 0x6f, 0x43, 0xed, 0x24, 0x85,
  0x0d, 0x55, 0x9a, 0x0d, 0xca, 0x4d, 0x9e, 0x5c,
  0xb9, 0xdd, 0xe2, 0x2f, 0xdf, 0x5c, 0xe0, 0x47,
  0x1f, 0x2c, 0xb2, 0xd6, 0xec, 0xf6, 0x2d, 0xcf,
  0xa6, 0x2f, 0x4f, 0x8e, 0x30, 0x50, 0x2e, 0x0e,
  0xd1, 0x21, 0xe5, 0x7b, 0x81, 0xb7, 0x6d, 0xeb,
  0x9b, 0xa2, 0xc1, 0x8e, 0x2d, 0x50, 0xc1, 0xb1,
  0xbd, 0xbb, 0x28, 0x27, 0x5b, 0x15, 0x6f, 0x99,
  0xe2, 0x1b, 0xe5, 0xa7, 0xc0, 0xe2, 0x59, 0x20,
  0x05, 0xbc, 0x33, 0xbf, 0xc6, 0xf7, 0x5f, 0x9f,
  0xe3, 0xe7, 0xb3, 0xb7, 0xe9, 0xa4, 0xfd, 0xcd,
  0xa2, 0x9c, 0x28, 0x8e, 0x8d, 0xd7, 0x7b, 0xda,
  0x77, 0x64, 0xc2, 0x3d, 0xca, 0xd8, 0x52, 0x00,
  0x8e, 0x5a, 0xa1, 0x8d, 0x9a, 0x92, 0x94, 0x08,
  0xf7, 0xef, 0xa9, 0xf5, 0x6d, 0x64, 0xe8, 0x89,
  0xfd, 0xdc, 0x9f, 0x07, 0xef, 0x4d, 0x42, 0x0b,
  0xa9, 0xd5, 0x15, 0x7e, 0x7a, 0x7e, 0x89, 0x1f,
  0xbc, 0x31, 0xc7, 0x87, 0xd7, 0x37, 0xfa, 0x96,
  0x3f, 0x3d, 0xb6, 0x4b, 0x9f, 0xd8, 0xc9, 0x5b,
  0x32, 0xac, 0xed, 0xc3, 0x84, 0x42, 0x1f, 0x10,
  0xbd, 0x9c, 0x99, 0xc6, 0xb2, 0x52, 0x15, 0xe0,
  0xae, 0x91, 0xed, 0xf5, 0xf6, 0xb2, 0x4e, 0xd5,
  0xb3, 0x21, 0x33, 0xcd, 0x86, 0x17, 0xd4, 0xd2,
  0x46, 0x9b, 0xbf, 0x7d, 0x67, 0x81, 0x97, 0x4f,
  0x5d, 0x63, 0x61, 0xad, 0xd5, 0xb3, 0xec, 0xbb,
  0x46, 0x6b, 0x41, 0x1b, 0x63, 0x63, 0x0d, 0x85,
  0xdf, 0x8b, 0x02, 0x3d, 0x19, 0xa0, 0x20, 0xf2,
  0xae, 0xee, 0x7d, 0xf1, 0xf5, 0x8d, 0xed, 0x2a,
  0x1e, 0xdd, 0xe5, 0xca, 0xb2, 0xf1, 0x3a, 0x0b,
  0x3e, 0x12, 0x42, 0x1c, 0x5a, 0x6d, 0x3a, 0xbf,
  0x78, 0x87, 0xbf, 0x78, 0x7d, 0x8e, 0x1f, 0x7d,
  0xb8, 0xc8, 0x46, 0x3b, 0xef, 0x1f, 0xc6, 0x76,
  0x55, 0x7c, 0x7b, 0x7d, 0x13, 0x63, 0x1c, 0x5b,
  0xa4, 0x6d, 0xf9, 0x80, 0xb0, 0xe8, 0xb0, 0xf0,
  0xe1, 0xea, 0x36, 0x04, 0x10, 0x4a, 0xce, 0x5c,
  0xe7, 0x18, 0x10, 0x4e, 0xb6, 0x04, 0x1e, 0xdc,
  0x3e, 0x9f, 0x0a, 0xbc, 0x76, 0xf9, 0x36, 0x7f,
  0xfe, 0xdf, 0x9f, 0xf0, 0xf6, 0xfc, 0x6a, 0x54,
  0xfc, 0x70, 0xb5, 0xec, 0xc2, 0x68, 0x21, 0xd8,
  0x3e, 0xae, 0x64, 0x07, 0x02, 0x90, 0x22, 0x57,
  0xb0, 0xdd, 0x57, 0x0b, 0x56, 0x78, 0x28, 0x58,
  0x0c, 0x94, 0x1e, 0xed, 0xd5, 0xb9, 0xb7, 0x36,
  0xdb, 0xbc, 0x7b, 0x63, 0x35, 0x77, 0x57, 0xb9,
  0x59, 0x55, 0xc9, 0x94, 0x29, 0x4e, 0x65, 0xbd,
  0xda, 0xbb, 0x3d, 0x0e, 0xdb, 0x89, 0x49, 0x65,
  0x1b, 0xa3, 0xbd, 0x40, 0xab, 0x9b, 0x52, 0x2d,
  0xf5, 0x91, 0xa1, 0xd8, 0x75, 0x1a, 0x15, 0xcc,
  0xf6, 0x9a, 0x59, 0x5e, 0x3b, 0xff, 0x27, 0xe2,
  0x26, 0x3f, 0x6d, 0x0d, 0x12, 0xbc, 0x9f, 0x8a,
  0x20, 0x95, 0x94, 0x3f, 0xfc, 0xd2, 0x38, 0x5f,
  0x9e, 0x8c, 0x3b, 0x5d, 0xbe, 0x37, 0x29, 0xc1,
  0x2f, 0x39, 0x61, 0xf6, 0x22, 0x42, 0x4f, 0x01,
  0x04, 0xf3, 0xb4, 0x99, 0x09, 0x4c, 0x7f, 0xf7,
  0xd6, 0x66, 0x87, 0x89, 0x7a, 0x7f, 0x47, 0x28,
  0x66, 0xce, 0x5e, 0xff, 0xeb, 0x77, 0x53, 0x70,
  0x93, 0xa8, 0xd9, 0x65, 0x2d, 0xff, 0x9e, 0xb0,
  0x96, 0xb6, 0xf9, 0xca, 0x7d, 0xbb, 0x79, 0xe6,
  0xf0, 0x5e, 0x4a, 0x05, 0x21, 0xf7, 0xd6, 0x9d,
  0x8e, 0x06, 0x2b, 0x71, 0x9b, 0xed, 0x9f, 0x9d,
  0x63, 0xec, 0x45, 0x81, 0x9c, 0x00, 0xac, 0xf4,
  0x9d, 0xb2, 0xf1, 0x2f, 0x67, 0xa5, 0x78, 0x6d,
  0xad, 0xdd, 0x57, 0x00, 0xe2, 0x0e, 0xa3, 0xf5,
  0x70, 0x86, 0xc6, 0x44, 0x19, 0x9b, 0xef, 0x1b,
  0x2d, 0xac, 0xb6, 0xdb, 0x4c, 0x4f, 0x0e, 0xf2,
  0xfb, 0x0f, 0xde, 0xd5, 0x73, 0x9c, 0x01, 0x30,
  0xbf, 0xda, 0xcc, 0xb4, 0x4b, 0x42, 0xfc, 0xfe,
  0xbf, 0x07, 0x05, 0xb6, 0x36, 0x81, 0x60, 0xd5,
  0xc2, 0x11, 0x5f, 0xf4, 0xd4, 0xb5, 0x00, 0x17,
  0x97, 0x9a, 0x3c, 0x34, 0x5e, 0xdf, 0xb2, 0x08,
  0xfb, 0xae, 0xd5, 0x72, 0x38, 0x7a, 0x53, 0xa9,
  0xe4, 0x1a, 0x79, 0xa7, 0xdb, 0x65, 0x64, 0x38,
  0xe1, 0x8f, 0x8f, 0x1e, 0xe4, 0xbe, 0xc6, 0x60,
  0xdf, 0xb2, 0x2f, 0xdc, 0xf2, 0x43, 0xec, 0x70,
  0xbd, 0xc0, 0x9b, 0x42, 0xdc, 0x8e, 0x6c, 0xea,
  0x6b, 0x02, 0x62, 0xec, 0xd7, 0xc6, 0xfe, 0xf0,
  0x81, 0x99, 0x1b, 0x77, 0xf8, 0xfa, 0xf4, 0xd6,
  0x0d, 0x0c, 0x57, 0x6e, 0x6d, 0xaf, 0x30, 0x31,
  0x8b, 0x1b, 0x2a, 0xd0, 0x94, 0x88, 0xb0, 0x99,
  0x74, 0x79, 0xe6, 0xd8, 0x18, 0x4f, 0x1e, 0xdc,
  0xbd, 0x75, 0xa1, 0x41, 0x9a, 0x59, 0x58, 0xf3,
  0x80, 0x73, 0x08, 0x25, 0x12, 0x4a, 0x51, 0x2a,
  0x14, 0x40, 0xd6, 0x64, 0x44, 0xc4, 0x4e, 0xc1,
  0x9b, 0x15, 0x1b, 0x5d, 0xe8, 0xfc, 0x5a, 0x9b,
  0xcb, 0xb7, 0x9b, 0x1c, 0x1a, 0xed, 0xdd, 0x23,
  0x0c, 0x69, 0x9f, 0x28, 0x9d, 0x91, 0x9a, 0x39,
  0x5a, 0x5b, 0xc7, 0x6a, 0xb7, 0xc3, 0x63, 0x53,
  0xc3, 0x3c, 0x7b, 0x64, 0x5f, 0x7f, 0xa7, 0x1a,
  0xa4, 0xd9, 0xe5, 0x4d, 0xe6, 0xd7, 0xda, 0x8e,
  0xf5, 0xd1, 0x61, 0x1c, 0xeb, 0x8e, 0xc3, 0x60,
  0xd6, 0x13, 0x17, 0x1e, 0xe2, 0x1d, 0xd6, 0xab,
  0x97, 0x56, 0xb6, 0xac, 0xc0, 0x7a, 0x77, 0x2b,
  0x88, 0xd4, 0xac, 0xed, 0xa7, 0x02, 0x2b, 0x9d,
  0x0e, 0x7b, 0xf7, 0x94, 0xf9, 0xd3, 0xdf, 0x38,
  0xc4, 0xef, 0x4d, 0x4f, 0xec, 0x08, 0x3c, 0xc0,
  0xab, 0x17, 0x96, 0x00, 0x3b, 0xe5, 0x1d, 0xd1,
  0x29, 0xbf, 0x8b, 0xa4, 0x47, 0x19, 0xbd, 0x19,
  0x60, 0x9c, 0x91, 0x5e, 0x78, 0xc4, 0x85, 0x31,
  0xb7, 0x56, 0x67, 0x16, 0x2d, 0x4e, 0xcf, 0xaf,
  0x73, 0xf2, 0xf0, 0x28, 0x07, 0x86, 0x8b, 0x9d,
  0xa1, 0x06, 0x2e, 0x7a, 0xb6, 0xc8, 0xbc, 0xdb,
  0x91, 0x94, 0xc1, 0x41, 0xc5, 0x37, 0x8f, 0x4e,
  0xf2, 0xc0, 0xd8, 0xd0, 0x8e, 0x40, 0xdb, 0x34,
  0xb7, 0xd2, 0xe4, 0xd4, 0xdc, 0xaa, 0x73, 0x9e,
  0x1e, 0x70, 0x60, 0xaa, 0x19, 0xd4, 0x45, 0x42,
  0x28, 0x14, 0x79, 0x28, 0xbd, 0x30, 0xcf, 0x4a,
  0x56, 0x5f, 0xeb, 0x8a, 0xba, 0x22, 0xfc, 0xf0,
  0xbd, 0x9b, 0x3d, 0x27, 0x3d, 0x9d, 0xf6, 0x53,
  0xa1, 0x2b, 0xc2, 0x1d, 0x3a, 0x7c, 0x75, 0xba,
  0xc1, 0x0b, 0xbf, 0x7e, 0xef, 0xa7, 0x06, 0x9f,
  0x8a, 0xf0, 0x37, 0xef, 0x2e, 0xd0, 0x25, 0x06,
  0x2d, 0x56, 0xf3, 0x41, 0x5f, 0x23, 0x64, 0x6d,
  0x51, 0x2a, 0x0c, 0x83, 0xb8, 0x02, 0x7d, 0xfc,
  0x56, 0xca, 0xf7, 0x07, 0xec, 0x8a, 0x8c, 0x5d,
  0xe7, 0xbb, 0xb0, 0xd4, 0xe4, 0x5f, 0xcf, 0x2f,
  0xf3, 0xb5, 0x23, 0x79, 0xe7, 0x25, 0x86, 0xf6,
  0x1b, 0xdd, 0x0e, 0x8f, 0x1d, 0x1a, 0xe2, 0x1b,
  0xd3, 0xe3, 0x0c, 0x94, 0x4b, 0xb9, 0xe7, 0x76,
  0x92, 0xfe, 0xe5, 0xdc, 0x2d, 0xce, 0x2f, 0x6d,
  0x06, 0xca, 0x08, 0xc0, 0x93, 0x39, 0x6c, 0xfe,
  0x76, 0xfb, 0x01, 0x90, 0xd1, 0x3c, 0x46, 0x9a,
  0xa2, 0xd7, 0xe7, 0xed, 0x3a, 0x9c, 0x5b, 0x9a,
  0x32, 0xa6, 0xf0, 0xe3, 0x8f, 0x97, 0x99, 0x18,
  0xaa, 0xf0, 0xc8, 0x64, 0xac, 0xd5, 0xdd, 0xf5,
  0x84, 0x03, 0x7b, 0xca, 0x3c, 0x77, 0xf4, 0x00,
  0x93, 0xf5, 0xfe, 0xc3, 0xe7, 0x7e, 0xe9, 0xf4,
  0xd5, 0x55, 0xfe, 0xe9, 0xa3, 0xc5, 0x60, 0x37,
  0x58, 0xec, 0xe9, 0x9d, 0xf6, 0xad, 0x50, 0x1c,
  0x8e, 0xe2, 0x6e, 0x76, 0x6f, 0x01, 0x04, 0xe2,
  0x75, 0xe6, 0xa0, 0xc4, 0xaf, 0xbf, 0x63, 0x16,
  0x2a, 0x6d, 0x5f, 0x41, 0x84, 0x97, 0xdf, 0xbe,
  0x4e, 0x82, 0xe2, 0xe1, 0x49, 0xdf, 0x37, 0x78,
  0xf6, 0xfe, 0xbd, 0xbf, 0x34, 0x68, 0x9b, 0xde,
  0x9a, 0x5f, 0xe5, 0xaf, 0xde, 0x9a, 0xa7, 0x9b,
  0xb1, 0xf7, 0xd4, 0xd1, 0x3e, 0x10, 0x42, 0xe8,
  0x7c, 0xa1, 0x10, 0x3c, 0x78, 0x1f, 0xe0, 0xfd,
  0x86, 0x10, 0xdb, 0x79, 0x8e, 0x56, 0xe2, 0x2a,
  0xb4, 0x05, 0xdb, 0x5d, 0x5b, 0xed, 0x14, 0x5e,
  0x7a, 0x6b, 0x81, 0x7f, 0xbf, 0xb0, 0xfc, 0xa9,
  0x26, 0x3a, 0x7b, 0x25, 0x11, 0xe1, 0xdf, 0x3e,
  0xbe, 0xc5, 0x4b, 0x6f, 0xce, 0xd3, 0xea, 0xc6,
  0xed, 0x48, 0x45, 0x5c, 0x5b, 0xfc, 0xce, 0xb1,
  0x4c, 0x87, 0xc8, 0x75, 0xb9, 0xf3, 0x65, 0xf7,
  0x64, 0x80, 0x95, 0x6c, 0x62, 0x7c, 0x40, 0xb8,
  0x27, 0x07, 0x54, 0x6e, 0x89, 0x3a, 0x31, 0xf3,
  0x64, 0xa9, 0xc0, 0x3f, 0x9c, 0x5d, 0xe4, 0xc3,
  0x9b, 0x1b, 0xfc, 0xc1, 0xb1, 0xbd, 0xec, 0xab,
  0xf7, 0xee, 0xc6, 0x6e, 0x27, 0x5d, 0x5f, 0x6f,
  0xf1, 0xc3, 0x77, 0xaf, 0xf3, 0xfe, 0xcd, 0x8d,
  0xc8, 0xd3, 0x87, 0xe0, 0x63, 0xea, 0x4b, 0x9e,
  0x0d, 0x04, 0x5d, 0xed, 0x2d, 0x04, 0x20, 0x21,
  0x78, 0x5f, 0x91, 0xee, 0xb7, 0x26, 0x19, 0x53,
  0xc0, 0xf4, 0xe6, 0xe2, 0x85, 0x4a, 0xb3, 0x74,
  0x2d, 0xf0, 0xc1, 0xcd, 0x3b, 0xbc, 0xf0, 0x5f,
  0x9f, 0xf0, 0xd4, 0xdd, 0x23, 0x7c, 0xe5, 0x9e,
  0xc6, 0x8e, 0x05, 0x71, 0x63, 0xbd, 0xc5, 0xab,
  0x17, 0x97, 0xf9, 0xf9, 0xec, 0x32, 0xed, 0x88,
  0xe2, 0x79, 0xf0, 0x69, 0x00, 0x3e, 0x8d, 0x98,
  0x19, 0x9b, 0xc2, 0x76, 0x7c, 0x80, 0x13, 0x82,
  0x1f, 0x99, 0x05, 0x12, 0x55, 0x26, 0x02, 0x88,
  0x16, 0x82, 0xf7, 0x03, 0xb8, 0x65, 0xb2, 0x2e,
  0x76, 0x62, 0x43, 0xd1, 0x16, 0xf8, 0xcf, 0xcb,
  0x2b, 0xfc, 0x6c, 0xf6, 0x36, 0x47, 0xf6, 0x0c,
  0x70, 0x7c, 0xbc, 0xce, 0x91, 0xb1, 0x5d, 0xec,
  0x1f, 0xae, 0xe6, 0x3a, 0x3d, 0xad, 0x6e, 0xca,
  0xd5, 0x95, 0x16, 0xe7, 0x16, 0x37, 0x38, 0xb3,
  0xb0, 0xce, 0xc7, 0x8b, 0x77, 0x32, 0xed, 0xb0,
  0x0e, 0xaf, 0x08, 0x7c, 0x81, 0x1f, 0xc0, 0x9b,
  0x43, 0x1a, 0x46, 0x81, 0x4c, 0x34, 0xb0, 0x02,
  0xf0, 0xe6, 0x42, 0xe4, 0xff, 0x4c, 0x31, 0x2a,
  0xd8, 0x8d, 0x65, 0xf6, 0xe4, 0x88, 0x1d, 0x27,
  0x99, 0x7d, 0x43, 0xa6, 0xbf, 0x8f, 0x0a, 0x05,
  0xa4, 0x5f, 0x12, 0xf4, 0x22, 0xe9, 0x39, 0x3b,
  0x70, 0x11, 0x61, 0xa8, 0x5a, 0x62, 0xb0, 0xa2,
  0x85, 0xb0, 0xd1, 0x4e, 0x59, 0x6b, 0x76, 0x02,
  0x8f, 0xad, 0x7f, 0xfc, 0x48, 0x5f, 0x1c, 0xc5,
  0x43, 0xa0, 0x1e, 0xbc, 0xb8, 0xf1, 0x86, 0x37,
  0x5f, 0x29, 0x30, 0x91, 0x18, 0xab, 0x15, 0x80,
  0xaf, 0x57, 0xd9, 0xe9, 0x0b, 0xdb, 0x4e, 0xd1,
  0x53, 0x52, 0x3a, 0xee, 0xb9, 0x1d, 0x1a, 0x6e,
  0x07, 0x89, 0x60, 0x76, 0x66, 0xf8, 0x5d, 0x58,
  0xca, 0x9e, 0x0b, 0x28, 0xd7, 0xe7, 0x57, 0x7e,
  0x78, 0x6d, 0xa4, 0xbb, 0xd2, 0xec, 0xb2, 0xe2,
  0xd6, 0x00, 0xe2, 0xd9, 0x26, 0xdf, 0x86, 0x10,
  0x80, 0xef, 0x9b, 0xa4, 0x0e, 0x90, 0x15, 0x88,
  0x07, 0x9f, 0x06, 0x02, 0x89, 0x1c, 0x75, 0xac,
  0x78, 0x97, 0x65, 0x19, 0x60, 0xbf, 0xb4, 0x10,
  0x44, 0xf4, 0xb6, 0x12, 0x3b, 0x82, 0x13, 0x0d,
  0xd6, 0x6d, 0x42, 0xb4, 0x03, 0x1a, 0x03, 0xd8,
  0x3f, 0xa7, 0x70, 0xf3, 0x15, 0x62, 0x79, 0x63,
  0x26, 0x96, 0x91, 0x80, 0x79, 0x82, 0xe5, 0x61,
  0x38, 0xf1, 0xea, 0xb5, 0x20, 0xe6, 0xfd, 0xa0,
  0xa5, 0x19, 0xc7, 0x16, 0xda, 0x7c, 0x08, 0x32,
  0x75, 0xcf, 0xc6, 0x6c, 0xf0, 0x1d, 0x3a, 0x27,
  0x06, 0x77, 0x2b, 0x14, 0x40, 0xc7, 0x94, 0x1d,
  0x85, 0x15, 0x3d, 0x0e, 0xc8, 0xee, 0xc3, 0xb3,
  0x2d, 0xf6, 0xc3, 0x5c, 0xb7, 0x37, 0xcf, 0x40,
  0x0e, 0x67, 0x92, 0xed, 0x64, 0xa7, 0x03, 0x4d,
  0x00, 0x3a, 0x00, 0x6b, 0xe0, 0x67, 0xee, 0xe5,
  0x69, 0x1c, 0x3a, 0x3c, 0x27, 0x14, 0x03, 0x3e,
  0xcd, 0x31, 0x45, 0xbc, 0x60, 0xb2, 0xca, 0x0e,
  0x18, 0x60, 0xbf, 0xb1, 0x69, 0x67, 0x1b, 0x26,
  0x96, 0xe6, 0x4e, 0x20, 0x12, 0xed, 0xc3, 0xf3,
  0x33, 0x3b, 0x1e, 0x5c, 0x94, 0x0f, 0x6e, 0xab,
  0x8a, 0x17, 0x40, 0x91, 0x47, 0xce, 0x6b, 0x9e,
  0x00, 0x8c, 0x07, 0xee, 0xff, 0xb3, 0x36, 0x6f,
  0x41, 0xa6, 0x21, 0x78, 0xfb, 0xbc, 0xe7, 0x60,
  0xd7, 0xe0, 0x4c, 0xad, 0x00, 0x04, 0xfb, 0x8d,
  0x4d, 0x2a, 0x1b, 0x9d, 0x76, 0xcb, 0x6d, 0x35,
  0x75, 0x61, 0xce, 0x50, 0xde, 0x79, 0x7c, 0xec,
  0x3e, 0x3c, 0xeb, 0x00, 0x83, 0x6d, 0xa9, 0x16,
  0x80, 0xf1, 0x03, 0x40, 0xe0, 0x30, 0xad, 0x49,
  0x64, 0xb1, 0x87, 0x1c, 0xb0, 0x59, 0xc1, 0xc0,
  0x8b, 0x40, 0x10, 0x99, 0xb0, 0x96, 0x73, 0x82,
  0x12, 0x9a, 0x82, 0x7d, 0x5f, 0x3b, 0xb7, 0x6e,
  0xbb, 0x05, 0xa9, 0x6c, 0x02, 0x9b, 0x68, 0xc6,
  0x3b, 0x01, 0xac, 0x01, 0x4b, 0x34, 0x37, 0xe6,
  0x97, 0x67, 0xcf, 0x8a, 0x80, 0x5e, 0xa8, 0x4a,
  0xca, 0x48, 0xb7, 0x4d, 0xaa, 0x54, 0x0e, 0xa4,
  0xa5, 0x75, 0x62, 0x3a, 0x45, 0x6e, 0x43, 0x52,
  0xe0, 0x0c, 0x2d, 0x18, 0xeb, 0x00, 0x8b, 0x23,
  0x91, 0x14, 0x9b, 0x82, 0xc4, 0xf9, 0x91, 0x23,
  0x74, 0xd7, 0xd6, 0x11, 0x06, 0x61, 0x31, 0x00,
  0x2f, 0x22, 0xa8, 0x6a, 0x0d, 0x31, 0xee, 0x78,
  0x69, 0xf6, 0xac, 0xd0, 0xdc, 0xb8, 0x0e, 0x2c,
  0xa3, 0xbf, 0x1a, 0x49, 0x6d, 0x30, 0x5e, 0x05,
  0x96, 0x48, 0xbb, 0x67, 0x97, 0xcf, 0xbc, 0xb6,
  0x78, 0x7b, 0xee, 0x92, 0xe6, 0x47, 0xa5, 0x0a,
  0xa5, 0xb2, 0x93, 0x6e, 0x1a, 0x36, 0xc0, 0x55,
  0xa8, 0x1b, 0x60, 0x0d, 0xcb, 0x4e, 0x76, 0x74,
  0xcd, 0x91, 0x46, 0x87, 0x76, 0xb0, 0x5d, 0xc4,
  0xbd, 0xd7, 0x35, 0x76, 0x9b, 0xcf, 0xf3, 0x54,
  0xb6, 0x75, 0xbb, 0x73, 0x82, 0xf2, 0xc2, 0xae,
  0x30, 0x44, 0xbe, 0x41, 0x55, 0x6b, 0x24, 0xbb,
  0x86, 0x48, 0x81, 0x95, 0xb9, 0x4b, 0x2c, 0x9f,
  0x79, 0x6d, 0xc9, 0x7c, 0x44, 0xb5, 0x6c, 0x30,
  0x3b, 0x1f, 0xb0, 0x86, 0xfe, 0xb4, 0xec, 0x03,
  0x16, 0x2e, 0x9f, 0x7e, 0xef, 0x95, 0x17, 0x9f,
  0x7e, 0xf4, 0xf9, 0xef, 0x96, 0xaa, 0x83, 0x43,
  0x24, 0x95, 0x01, 0x54, 0x25, 0x5e, 0xd2, 0x0a,
  0x35, 0xed, 0x97, 0xb5, 0x4c, 0x8f, 0xd1, 0x6a,
  0xd9, 0x32, 0xa1, 0x40, 0xeb, 0x85, 0xab, 0xb9,
  0x59, 0xfb, 0xcf, 0xfc, 0x5b, 0x3a, 0xeb, 0x3d,
  0xc3, 0xf1, 0x2c, 0x53, 0xa8, 0x14, 0x13, 0xca,
  0xac, 0x91, 0x92, 0x02, 0xad, 0x8d, 0x35, 0x66,
  0x5e, 0x79, 0xb1, 0xcb, 0xc2, 0xe5, 0x19, 0xe0,
  0x0c, 0x70, 0xd3, 0x0a, 0xc0, 0x0e, 0xcc, 0xed,
  0xc7, 0x86, 0x25, 0xd2, 0xee, 0x66, 0xfb, 0xe6,
  0xd5, 0xc6, 0x8d, 0xb9, 0x4b, 0x93, 0xa3, 0x87,
  0xa6, 0x93, 0xda, 0xc8, 0x6e, 0x0d, 0xcf, 0xae,
  0x30, 0x2a, 0x85, 0x52, 0x89, 0x3b, 0x77, 0x47,
  0x92, 0xb9, 0x26, 0x01, 0xa5, 0xf4, 0xe6, 0xe7,
  0xe0, 0xdf, 0x9e, 0x4b, 0xe6, 0x9e, 0x04, 0xe5,
  0x67, 0xdf, 0xd1, 0x1d, 0x31, 0xdd, 0x19, 0xb3,
  0x79, 0x29, 0x41, 0x39, 0xd1, 0x39, 0x2e, 0xcf,
  0x6a, 0xfe, 0xed, 0xbf, 0xfe, 0xb3, 0xee, 0xfa,
  0xa9, 0x9f, 0xbe, 0xcb, 0xe6, 0xc6, 0x8f, 0x81,
  0x77, 0x80, 0x0b, 0xc0, 0x4a, 0x4e, 0x31, 0xc0,
  0x24, 0x70, 0x3f, 0x70, 0x82, 0x4a, 0xed, 0x24,
  0xe3, 0x87, 0x4e, 0x34, 0x8e, 0x3f, 0xb1, 0xa7,
  0x31, 0x35, 0xad, 0xca, 0x95, 0xaa, 0x7b, 0xc8,
  0x2e, 0x45, 0x65, 0xb5, 0x1b, 0x3a, 0x3a, 0xc8,
  0x9f, 0x17, 0x5d, 0x67, 0x53, 0xd6, 0x41, 0x4a,
  0xc1, 0xb9, 0x77, 0x6e, 0xd9, 0x7c, 0x1f, 0x46,
  0xbb, 0xed, 0x16, 0x4b, 0xb3, 0x67, 0x65, 0xf9,
  0xcc, 0x6b, 0x4b, 0x2c, 0x5c, 0x9e, 0x31, 0x9f,
  0xcd, 0xfd, 0x02, 0x38, 0x87, 0xfe, 0x88, 0xd2,
  0x76, 0x5c, 0xa3, 0x94, 0x00, 0x13, 0xc0, 0x14,
  0xf6, 0xfb, 0xc1, 0xa4, 0xf4, 0x20, 0xb5, 0xc1,
  0x71, 0xf3, 0xa5, 0x45, 0xb8, 0xbb, 0xdc, 0xd6,
  0xde, 0x0f, 0xd3, 0xff, 0x6d, 0x0a, 0x3b, 0x16,
  0x3a, 0xa5, 0x40, 0x97, 0x54, 0x36, 0x69, 0x6e,
  0x5c, 0x37, 0x36, 0x7f, 0x06, 0x0d, 0xfc, 0x12,
  0x70, 0x15, 0x13, 0x01, 0xfc, 0xeb, 0xf9, 0x22,
  0x1b, 0xe8, 0x4f, 0x67, 0xbf, 0x80, 0xfe, 0xbe,
  0xc6, 0x7e, 0x63, 0xf3, 0x79, 0xfa, 0x6c, 0x36,
  0x4c, 0x51, 0x54, 0x44, 0x9b, 0xf3, 0x26, 0xda,
  0xd9, 0x2d, 0xa3, 0x6d, 0xfe, 0x0a, 0xb0, 0x48,
  0xb0, 0x6f, 0x1a, 0xb6, 0x6e, 0x7c, 0x05, 0xfd,
  0x65, 0xd5, 0x30, 0x9f, 0x6f, 0xf0, 0x36, 0x65,
  0x85, 0xd0, 0x41, 0x87, 0xba, 0x55, 0x73, 0x14,
  0xee, 0xc2, 0xda, 0x2e, 0x80, 0x98, 0xf6, 0x3b,
  0x7b, 0xf7, 0xff, 0x33, 0x65, 0x5d, 0x48, 0xdf,
  0x8d, 0x88, 0xff, 0x0b, 0x9b, 0x4e, 0x21, 0xaa,
  0xaf, 0xed, 0xd9, 0xb7, 0x00, 0x00, 0x00, 0x00,
  0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82
};

static void *
xmalloc (size_t size)
{
  void *ret = malloc (size);

  if (ret == NULL) {
    fprintf (stderr, "Malloc failed\n");
    exit (1);
  }
  return ret;
}

static void *
xrealloc (void *ptr, size_t size)
{
  void *ret = realloc (ptr, size);

  if (ret == NULL) {
    fprintf (stderr, "Realloc failed\n");
    exit (1);
  }
  return ret;
}

static char *
xstrdup (const char *s)
{
  char *ret = (char *) xmalloc (strlen (s) + 1);

  return strcpy (ret, s);
}

static char *
newstr (const char *str)
{
  char *ret = xstrdup (str);
  char *cp;
  char *np;

  cp = ret;
  np = ret;
  while (*cp) {
    if (*cp == '&') {
      if (strncmp (cp + 1, "lt;", 3) == 0) {
	cp += 4;
	*np++ = '<';
      }
      else if (strncmp (cp + 1, "gt;", 3) == 0) {
	cp += 4;
	*np++ = '>';
      }
      else if (strncmp (cp + 1, "amp;", 4) == 0) {
	cp += 5;
	*np++ = '&';
      }
      else if (strncmp (cp + 1, "apos;", 5) == 0) {
	cp += 6;
	*np++ = '\'';
      }
      else if (strncmp (cp + 1, "quot;", 5) == 0) {
	cp += 6;
	*np++ = '"';
      }
      else {
	*np++ = *cp++;
      }
    }
    else if (*cp == '\\' && cp[1] == 'n') {
      cp += 2;
      *np++ = '\n';
    }
    else {
      *np++ = *cp++;
    }
  }
  *np = '\0';
  cp = xstrdup (ret);
  free (ret);
  return cp;
}

static char *
newstr2 (char *old, const char *str, int len)
{
  unsigned int size = (old ? strlen (old) : 0) + len + 1;
  char *buf = (char *) xmalloc (size);
  char *ret;

  if (old) {
    strcpy (buf, old);
    memcpy (&buf[strlen (old)], str, len);
    free (old);
  }
  else {
    memcpy (buf, str, len);
  }
  buf[size - 1] = 0;
  if (start_cdata) {
    ret = buf;
  }
  else {
    ret = newstr (buf);
    free (buf);
  }
  return ret;
}

static double
convert_gpx_time (char *time)
{
  struct tm tm;

  memset (&tm, 0, sizeof (tm));
  if (sscanf (time, "%d-%d-%dT%d:%d:%dZ",
	      &tm.tm_year, &tm.tm_mon, &tm.tm_mday,
	      &tm.tm_hour, &tm.tm_min, &tm.tm_sec) == 6) {
    tm.tm_mon--;
    tm.tm_year -= 1900;
    tm.tm_isdst = -1;
    return mktime (&tm);
  }
  return 0;
}

static double
convert_time (char *str)
{
  struct tm tm;

  memset (&tm, 0, sizeof (tm));
  if (sscanf (str, "%04d:%02d:%2d %02d:%02d:%02d",
	      &tm.tm_year, &tm.tm_mon, &tm.tm_mday,
	      &tm.tm_hour, &tm.tm_min, &tm.tm_sec) == 6) {
    tm.tm_mon--;
    tm.tm_year -= 1900;
    tm.tm_isdst = -1;
    return mktime (&tm);
  }
  return 0;
}

static double
earth_radius (double lon)
{
  double a = 6378137.0;
  double b = 6356752.31424518;
  double tmp1 = a * a * cos (lon);
  double tmp2 = b * b * sin (lon);
  double tmp3 = a * cos (lon);
  double tmp4 = b * sin (lon);

  return sqrt ((tmp1 * tmp1 + tmp2 * tmp2) / (tmp3 * tmp3 + tmp4 * tmp4));
}

static double
earth_radius2 (double lon1, double lon2)
{
  return (earth_radius (lon1) + earth_radius (lon2)) / 2.0;
}

static double
calc_distance (double lon1, double lon2, double lat1, double lat2)
{
  return
    earth_radius2 (lon1, lon2) * acos (sin (lat1) * sin (lat2) +
				       cos (lat1) * cos (lat2) *
				       cos (lon1 - lon2));
}

static void
calc (char *str_lat1, char *str_lon1, double tim1,
      char *str_lat2, char *str_lon2, double tim2,
      double *distance, double *speed, double *heading)
{
  double lat1 = 0.0;
  double lon1 = 0.0;
  double lat2 = 0.0;
  double lon2 = 0.0;

  if (str_lat1) {
    lat1 = RAD (strtod (str_lat1, NULL));
  }
  if (str_lon1) {
    lon1 = RAD (strtod (str_lon1, NULL));
  }
  if (str_lat2) {
    lat2 = RAD (strtod (str_lat2, NULL));
  }
  if (str_lon2) {
    lon2 = RAD (strtod (str_lon2, NULL));
  }
  *distance = calc_distance (lon1, lon2, lat1, lat2);
  if (isnan (*distance)) {
    *distance = 0.0;
  }
  if (tim1 == tim2) {
    *speed = 0.0;
  }
  else {
    *speed = *distance / (tim2 - tim1);
  }
  *heading =
    atan2 (sin (lon2 - lon1) * cos (lat2),
	   cos (lat1) * sin (lat2) -
	   sin (lat1) * cos (lat2) * cos (lon2 - lon1)) * 180.0 / M_PI;
  if (*heading < 0) {
    *heading += 360.0;
  }
}

static double
calc_total_distance (track_type * track)
{
  double total_distance = 0;

  if (track->n_gpx_data) {
    unsigned int i;

    for (i = 0; i < track->n_gpx_data - 1; i++) {
      double distance;
      double speed;
      double heading;

      calc (track->gpx_data[i].lat, track->gpx_data[i].lon,
	    track->gpx_data[i].tim, track->gpx_data[i + 1].lat,
	    track->gpx_data[i + 1].lon, track->gpx_data[i + 1].tim, &distance,
	    &speed, &heading);
      total_distance += distance;
    }
  }
  return total_distance;
}

static void
trim (char *s)
{
  if (s) {
    while (isspace (*s)) {
      char *cp = s;

      while (*cp) {
	cp[0] = cp[1];
	cp++;
      }
    }
    while (*s && isspace (s[strlen (s) - 1])) {
      s[strlen (s) - 1] = '\0';
    }
  }
}

static void
filter (char *name, track_type * track)
{
  if (track->n_gpx_data) {
    unsigned int i;
    double total_distance = 0;

    for (i = 0; i < track->n_gpx_data; i++) {
      trim (track->gpx_data[i].lat);
      trim (track->gpx_data[i].lon);
      trim (track->gpx_data[i].ele);
      trim (track->gpx_data[i].time);
    }
    track->gpx_data[0].valid = 0;
    for (i = 0; i < track->n_gpx_data - 1; i++) {
      double distance;
      double speed;
      double heading;

      calc (track->gpx_data[i].lat, track->gpx_data[i].lon,
	    track->gpx_data[i].tim, track->gpx_data[i + 1].lat,
	    track->gpx_data[i + 1].lon, track->gpx_data[i + 1].tim,
	    &distance, &speed, &heading);
      track->gpx_data[i + 1].valid = 1;
      track->gpx_data[i + 1].distance = distance;
      track->gpx_data[i + 1].speed = speed;
      track->gpx_data[i + 1].heading = heading;
      track->gpx_data[i + 1].total_distance = total_distance;
      total_distance += distance;
      if (speed >= 300.0 / 3.6) {	/* >= 300 km/hour */
	printf ("%s, speed %.3f km/h\n", name ? name : "track", speed * 3.6);
      }
    }
  }
}

static void XMLCALL
startc (void *data)
{
  start_cdata = 1;
}

static void XMLCALL
endc (void *data)
{
  start_cdata = 0;
}

static void XMLCALL
start_gpx (void *data, const char *el, const char **attr)
{
  if (strcmp (el, "trk") == 0 || strcmp (el, "metadata") == 0) {
    state = 1;
  }
  else if (state == 1 && strcmp (el, "name") == 0) {
    state = 2;
    free (track_name);
    track_name = NULL;
  }
  else if (strcmp (el, "trkpt") == 0) {
    state = 3;
    free (gpx_tmp.lat);
    free (gpx_tmp.lon);
    free (gpx_tmp.ele);
    free (gpx_tmp.time);
    memset (&gpx_tmp, 0, sizeof (gpx_tmp));
    while (attr[0] && attr[1]) {
      if (strcmp (attr[0], "lat") == 0) {
	gpx_tmp.lat = newstr (attr[1]);
      }
      else if (strcmp (attr[0], "lon") == 0) {
	gpx_tmp.lon = newstr (attr[1]);
      }
      attr += 2;
    }
  }
  else if ((state == 3 || state == 5) && strcmp (el, "ele") == 0) {
    state = 4;
    free (gpx_tmp.ele);
    gpx_tmp.ele = NULL;
  }
  else if ((state == 3 || state == 4) && strcmp (el, "time") == 0) {
    state = 5;
    free (gpx_tmp.time);
    gpx_tmp.time = NULL;
  }
  else {
    state = 0;
  }
}

static void XMLCALL
end_gpx (void *data, const char *el)
{
  if (strcmp (el, "trkpt") == 0) {
    gpx_data = (gpx_data_type *) xrealloc (gpx_data,
					   (n_gpx_data +
					    1) * sizeof (gpx_data_type));
    gpx_data[n_gpx_data++] = gpx_tmp;
    memset (&gpx_tmp, 0, sizeof (gpx_tmp));
    state = 0;
  }
}

static void XMLCALL
data_gpx (void *data, const char *text, int len)
{
  if (state == 2 && len) {
    if (n_gpx_data) {
      track =
	(track_type *) xrealloc (track, (n_track + 1) * sizeof (track_type));
      track[n_track].track_name = track_name;
      track[n_track].n_gpx_data = n_gpx_data;
      track[n_track].gpx_data = gpx_data;
      filter (track_name, &track[n_track]);
      printf ("%s, distance = %.3f Km\n",
	      track_name ? track_name : "track",
	      calc_total_distance (&track[n_track]) / 1000.0);
      n_track++;
      track_name = NULL;
    }
    n_gpx_data = 0;
    gpx_data = NULL;
    track_name = newstr2 (track_name, text, len);
    state = 0;
  }
  else if (state == 4) {
    gpx_tmp.ele = newstr2 (gpx_tmp.ele, text, len);
  }
  else if (state == 5) {
    gpx_tmp.time = newstr2 (gpx_tmp.time, text, len);
    gpx_tmp.tim = convert_gpx_time (gpx_tmp.time);
  }
}

#define	STR_END		((void *) 0)

static char *
str_concat (const char *str, ...)
{
  char *ret;
  char *tmp_str;
  size_t len;
  va_list ap;
  va_list aq;

  va_start (ap, str);
  va_copy (aq, ap);
  len = strlen (str) + 1;
  while ((tmp_str = va_arg (aq, char *)) != STR_END)
  {
    len += strlen (tmp_str);
  }
  va_end (aq);
  ret = (char *) xmalloc (len);
  if (ret) {
    strcpy (ret, str);
    while ((tmp_str = va_arg (ap, char *)) != STR_END)
    {
      strcat (ret, tmp_str);
    }
  }
  va_end (ap);
  return ret;
}

static char *
find_char (char *str, char find)
{
  char *cp = str;

  while (*cp) {
    cp++;
  }
  while (cp != str && cp[-1] != find) {
    cp--;
  }
  return cp;
}

static void
make_lower (char *str)
{
  while (*str) {
    *str = tolower (*str);
    str++;
  }
}

static char *
patch_line (char *line, char *pos)
{
  char *tp = pos;

  while (tp != line && tp[-1] == ' ') {
    tp--;
  }
  *tp = '\0';
  pos++;
  while (*pos == ' ') {
    pos++;
  }
  tp = pos;
  while (*tp) {
    tp++;
  }
  while (tp != pos && (tp[-1] == '\r' || tp[-1] == '\n')) {
    tp--;
  }
  *tp = '\0';
  return pos;
}

static int
sort_picts (const void *a, const void *b)
{
  pict_type *pa = (pict_type *) a;
  pict_type *pb = (pict_type *) b;

  return pa->tim < pb->tim ? -1 : pa->tim > pb->tim ? 1 : 0;
}

static int
sort_tracks (const void *a, const void *b)
{
  track_type *ta = (track_type *) a;
  track_type *tb = (track_type *) b;

  return ta->gpx_data[0].tim < tb->gpx_data[0].tim ? -1 :
    ta->gpx_data[0].tim > tb->gpx_data[0].tim ? 1 : 0;
}

static void
load_gpx (char *filename)
{
  struct stat st;

  if (stat (filename, &st) >= 0) {
    FILE *fp;
    char *buf = (char *) xmalloc (st.st_size + 1);

    fp = fopen (filename, "rb");
    if (fp) {
      if ((int) fread (buf, 1, st.st_size, fp) == (int) st.st_size) {
	XML_Parser parser;

	buf[st.st_size] = 0;
	parser = XML_ParserCreate (NULL);
	if (parser) {
	  memset (&gpx_tmp, 0, sizeof (gpx_tmp));
	  XML_SetElementHandler (parser, start_gpx, end_gpx);
	  XML_SetCdataSectionHandler (parser, startc, endc);
	  XML_SetCharacterDataHandler (parser, data_gpx);
	  XML_SetUserData (parser, NULL);
	  if (XML_Parse (parser, buf, st.st_size, 1) == XML_STATUS_ERROR) {
	    fprintf (stderr, "Parse error at line %d:%s. File %s\n",
		     (int) XML_GetCurrentLineNumber (parser),
		     XML_ErrorString (XML_GetErrorCode (parser)), filename);
	  }
	  XML_StopParser (parser, XML_FALSE);
	  XML_ParserFree (parser);
	  if (n_gpx_data) {
	    track =
	      (track_type *) xrealloc (track,
				       (n_track + 1) * sizeof (track_type));
	    track[n_track].track_name = track_name;
	    track[n_track].n_gpx_data = n_gpx_data;
	    track[n_track].gpx_data = gpx_data;
	    filter (filename, &track[n_track]);
	    printf ("%s, distance = %.3f Km\n",
		    filename, calc_total_distance (&track[n_track]) / 1000.0);
	    n_track++;
	  }
	  n_gpx_data = 0;
	  gpx_data = NULL;
	  track_name = NULL;
	}
	else {
	  fprintf (stderr, "Cannot create parser for file '%s'\n", filename);
	}
      }
      else {
	fprintf (stderr, "Read error file '%s'\n", filename);
      }
      fclose (fp);
    }
    else {
      fprintf (stderr, "Cannot open file '%s'\n", filename);
    }
    free (buf);
  }
  else {
    fprintf (stderr, "Cannot open file '%s'\n", filename);
  }
}

static void
load_pict (char *filename, unsigned int is_video)
{
  int i;
  char *lower;
  char *cp;

  lower = xstrdup (filename);
  make_lower (lower);
  cp = find_char (lower, FILE_SEP_CHR);
  for (i = 0; i < n_cache; i++) {
    if (strcmp (cp, cache[i].name) == 0) {
      pict = (pict_type *) xrealloc (pict, (n_pict + 1) * sizeof (pict_type));
      pict[n_pict++] = cache[i];
      printf ("Use cache: %s\n", lower);
      n_cache--;
      for (; i < n_cache; i++) {
	cache[i] = cache[i + 1];
      }
      free (lower);
      return;
    }
  }
  free (lower);

#if LINUX
  if (is_video == 0 && (use_jhead == 0 && use_exiftool == 0)) {
    ExifLoader *l;
    ExifData *ed;
    ExifTag date_tags[] =
      { EXIF_TAG_DATE_TIME_ORIGINAL, EXIF_TAG_DATE_TIME_DIGITIZED };
    ExifTag tags[] = { EXIF_TAG_MAKE, EXIF_TAG_MODEL, EXIF_TAG_EXPOSURE_TIME,
      EXIF_TAG_FNUMBER, EXIF_TAG_ISO_SPEED_RATINGS, EXIF_TAG_FLASH,
      EXIF_TAG_PIXEL_X_DIMENSION, EXIF_TAG_PIXEL_Y_DIMENSION,
      EXIF_TAG_FOCAL_LENGTH_IN_35MM_FILM
    };

    l = exif_loader_new ();
    exif_loader_write_file (l, filename);
    ed = exif_loader_get_data (l);
    exif_loader_unref (l);
    if (ed) {
      int j;
      int k;

      for (j = 0; j < (int) (sizeof (date_tags) / sizeof (date_tags[0])); j++) {
	if (exif_data_get_entry (ed, date_tags[j])) {
	  for (k = 0; k < EXIF_IFD_COUNT; k++) {
	    ExifEntry *e;

	    e = exif_content_get_entry (ed->ifd[k], date_tags[j]);
	    if (e) {
	      double tim;
	      char str[1000];

	      exif_entry_get_value (e, str, sizeof (str));
	      tim = convert_time (str);
	      if (tim != 0) {
		time_t t;

		pict =
		  (pict_type *) xrealloc (pict,
					  (n_pict + 1) * sizeof (pict_type));
		memset (&pict[n_pict], 0, sizeof (pict_type));
		pict[n_pict].name = xstrdup (filename);
		pict[n_pict].is_video = is_video;
		pict[n_pict].time = xstrdup (str);
		pict[n_pict].tim = tim;
		t = tim;
		printf ("Pict %s (%s) %s", pict[n_pict].name, str,
			ctime (&t));
		for (j = 0; j < (int) (sizeof (tags) / sizeof (tags[0])); j++) {
		  for (k = 0; k < EXIF_IFD_COUNT; k++) {
		    if (exif_data_get_entry (ed, tags[j])) {
		      e = exif_content_get_entry (ed->ifd[k], tags[j]);
		      if (e) {
			exif_entry_get_value (e, str, sizeof (str));
			switch (tags[j]) {
			case EXIF_TAG_MAKE:
			  free (pict[n_pict].manufacturer);
			  pict[n_pict].manufacturer = xstrdup (str);
			  break;
			case EXIF_TAG_MODEL:
			  free (pict[n_pict].model);
			  pict[n_pict].model = xstrdup (str);
			  break;
			case EXIF_TAG_EXPOSURE_TIME:
			  free (pict[n_pict].exposure_time);
			  pict[n_pict].exposure_time = xstrdup (str);
			  break;
			case EXIF_TAG_FNUMBER:
			  free (pict[n_pict].f_number);
			  pict[n_pict].f_number = xstrdup (str);
			  break;
			case EXIF_TAG_ISO_SPEED_RATINGS:
			  free (pict[n_pict].iso_speed_ratings);
			  pict[n_pict].iso_speed_ratings = xstrdup (str);
			  break;
			case EXIF_TAG_FLASH:
			  free (pict[n_pict].flash);
			  pict[n_pict].flash = xstrdup (str);
			  break;
			case EXIF_TAG_PIXEL_X_DIMENSION:
			  free (pict[n_pict].pixel_x_dimension);
			  pict[n_pict].pixel_x_dimension = xstrdup (str);
			  break;
			case EXIF_TAG_PIXEL_Y_DIMENSION:
			  free (pict[n_pict].pixel_y_dimension);
			  pict[n_pict].pixel_y_dimension = xstrdup (str);
			  break;
			case EXIF_TAG_FOCAL_LENGTH_IN_35MM_FILM:
			  free (pict[n_pict].focal_length_in_35mm);
			  pict[n_pict].focal_length_in_35mm = xstrdup (str);
			  break;
			default:
			  break;
			}
		      }
		    }
		  }
		}
		k = 0;
		n_pict++;
		break;
	      }
	    }
	  }
	  if (k != EXIF_IFD_COUNT) {
	    break;
	  }
	}
      }
      exif_data_unref (ed);
    }
  }
  else
#endif
  if (use_exiftool == 0 || is_video == 1) {
    FILE *et;
    char *command;

    command = str_concat ("exiftool ", filename, STR_END);
    et = popen (command, "r");
    if (et) {
      char line[1000];

      pict = (pict_type *) xrealloc (pict, (n_pict + 1) * sizeof (pict_type));
      memset (&pict[n_pict], 0, sizeof (pict_type));
      pict[n_pict].name = xstrdup (filename);
      pict[n_pict].is_video = is_video;
      while (fgets (line, sizeof (line), et)) {
	cp = strchr (line, ':');
	if (*cp == ':') {
	  char *ep = find_char (filename, '.');

	  cp = patch_line (line, cp);
	  if (pict[n_pict].time == NULL &&
	      (((strcmp (ep, "mp4") == 0 || strcmp (ep, "MP4") == 0 ||
		 strcmp (ep, "mts") == 0 || strcmp (ep, "MTS") == 0) &&
		strcmp (line, "Date/Time Original") == 0) ||
	       ((strcmp (ep, "mov") == 0 || strcmp (ep, "MOV") == 0) &&
		strcmp (line, "Create Date") == 0))) {
	    double tim;

	    free (pict[n_pict].time);
	    pict[n_pict].time = xstrdup (cp);
	    tim = convert_time (cp);
	    if (tim != 0) {
	      time_t t;

	      if (is_video) {
		tim += fix_mp4;
	      }
	      pict[n_pict].tim = tim;
	      t = tim;
	      printf ("Pict %s (%s) %s", pict[n_pict].name, cp, ctime (&t));
	    }
	  }
	  else if (strcmp (line, "Make") == 0 ||
		   strcmp (line, "Vendor ID") == 0) {
	    free (pict[n_pict].manufacturer);
	    pict[n_pict].manufacturer = xstrdup (cp);
	  }
	  else if (strcmp (line, "Camera Model Name") == 0) {
	    free (pict[n_pict].model);
	    pict[n_pict].model = xstrdup (cp);
	  }
	  else if (strcmp (line, "Exposure Time") == 0) {
	    free (pict[n_pict].exposure_time);
	    pict[n_pict].exposure_time = xstrdup (cp);
	  }
	  else if (strcmp (line, "F Number") == 0) {
	    free (pict[n_pict].f_number);
	    pict[n_pict].f_number = xstrdup (cp);
	  }
	  else if (strcmp (line, "ISO") == 0) {
	    free (pict[n_pict].iso_speed_ratings);
	    pict[n_pict].iso_speed_ratings = xstrdup (cp);
	  }
	  else if (strcmp (line, "Flash") == 0) {
	    free (pict[n_pict].flash);
	    pict[n_pict].flash = xstrdup (cp);
	  }
	  else if (strcmp (line, "Duration") == 0) {
	    free (pict[n_pict].duration);
	    pict[n_pict].duration = xstrdup (cp);
	  }
	  else if (strcmp (line, "Image Width") == 0) {
	    free (pict[n_pict].pixel_x_dimension);
	    pict[n_pict].pixel_x_dimension = xstrdup (cp);
	  }
	  else if (strcmp (line, "Image Height") == 0) {
	    free (pict[n_pict].pixel_y_dimension);
	    pict[n_pict].pixel_y_dimension = xstrdup (cp);
	  }
	  else if (strcmp (line, "Focal Length In 35mm Format") == 0) {
	    free (pict[n_pict].focal_length_in_35mm);
	    pict[n_pict].focal_length_in_35mm = xstrdup (cp);
	  }
	}
      }
      n_pict++;
      pclose (et);
    }
    free (command);
  }
  else {
    FILE *et;
    char *command;

    command = str_concat ("jhead ", filename, STR_END);
    et = popen (command, "r");
    if (et) {
      char line[1000];

      pict = (pict_type *) xrealloc (pict, (n_pict + 1) * sizeof (pict_type));
      memset (&pict[n_pict], 0, sizeof (pict_type));
      pict[n_pict].name = xstrdup (filename);
      pict[n_pict].is_video = is_video;
      while (fgets (line, sizeof (line), et)) {
	cp = strchr (line, ':');
	if (*cp == ':') {
	  cp = patch_line (line, cp);
	  if (pict[n_pict].time == NULL && strcmp (line, "Date/Time") == 0) {
	    double tim;

	    free (pict[n_pict].time);
	    pict[n_pict].time = xstrdup (cp);
	    tim = convert_time (cp);
	    if (tim != 0) {
	      time_t t;

	      pict[n_pict].tim = tim;
	      t = tim;
	      printf ("Pict %s (%s) %s", pict[n_pict].name, cp, ctime (&t));
	    }
	  }
	  else if (strcmp (line, "Camera make") == 0) {
	    free (pict[n_pict].manufacturer);
	    pict[n_pict].manufacturer = xstrdup (cp);
	  }
	  else if (strcmp (line, "Camera model") == 0) {
	    free (pict[n_pict].model);
	    pict[n_pict].model = xstrdup (cp);
	  }
	  else if (strcmp (line, "Exposure time") == 0) {
	    free (pict[n_pict].exposure_time);
	    pict[n_pict].exposure_time = xstrdup (cp);
	  }
	  else if (strcmp (line, "Aperture") == 0) {
	    free (pict[n_pict].f_number);
	    pict[n_pict].f_number = xstrdup (cp);
	  }
	  else if (strcmp (line, "ISO equiv.") == 0) {
	    free (pict[n_pict].iso_speed_ratings);
	    pict[n_pict].iso_speed_ratings = xstrdup (cp);
	  }
	  else if (strcmp (line, "Flash used") == 0) {
	    free (pict[n_pict].flash);
	    pict[n_pict].flash = xstrdup (cp);
	  }
	  else if (strcmp (line, "Resolution") == 0) {
	    char *ep = cp;

	    while (*ep && *ep != ' ') {
	      ep++;
	    }
	    if (*ep) {
	      *ep++ = '\0';
	      free (pict[n_pict].pixel_x_dimension);
	      pict[n_pict].pixel_x_dimension = xstrdup (cp);
	      while (*ep == ' ' || *ep == 'x') {
		ep++;
	      }
	      free (pict[n_pict].pixel_y_dimension);
	      pict[n_pict].pixel_y_dimension = xstrdup (ep);
	    }
	  }
	  else if (strcmp (line, "Focal length") == 0) {
	    free (pict[n_pict].focal_length_in_35mm);
	    pict[n_pict].focal_length_in_35mm = xstrdup (cp);
	  }
	}
      }
      n_pict++;
      pclose (et);
    }
    free (command);
  }
}

static void
free_track (track_type * track, unsigned int n_track)
{
  unsigned int i;
  unsigned int j;

  for (i = 0; i < n_track; i++) {
    for (j = 0; j < track[i].n_gpx_data; j++) {
      free (track[i].gpx_data[j].lat);
      free (track[i].gpx_data[j].lon);
      free (track[i].gpx_data[j].ele);
      free (track[i].gpx_data[j].time);
    }
    free (track[i].gpx_data);
    free (track[i].track_name);
  }
  free (track);
}

static void
free_pict (pict_type * pict, unsigned int n_pict)
{
  unsigned int i;

  for (i = 0; i < n_pict; i++) {
    free (pict[i].name);
    free (pict[i].time);
    free (pict[i].manufacturer);
    free (pict[i].model);
    free (pict[i].exposure_time);
    free (pict[i].f_number);
    free (pict[i].iso_speed_ratings);
    free (pict[i].flash);
    free (pict[i].duration);
    free (pict[i].pixel_x_dimension);
    free (pict[i].pixel_y_dimension);
    free (pict[i].focal_length_in_35mm);
  }
  free (pict);
}

static void
read_cache (char *output)
{
  DIR *dir;
  char *dname;

  free_pict (cache, n_cache);
  n_cache = 0;
  cache = NULL;
  dname = str_concat (output, FILE_SEP_STR "cache", STR_END);
  dir = opendir (dname);
  if (dir) {
    struct dirent *dirent;

    while ((dirent = readdir (dir)) != NULL) {
      char *name = str_concat (dname, FILE_SEP_STR, dirent->d_name, STR_END);
      char *cp = find_char (name, '.');

      if (strcmp (cp, "jpg") == 0 ||
	  (use_video &&
	   (strcmp (cp, "mp4") == 0 || strcmp (cp, "mov") == 0 ||
	    strcmp (cp, "mts") == 0))) {
	FILE *fp;

	cp = find_char (name, FILE_SEP_CHR);
	fp = fopen (name, "rb");
	if (fp) {
	  char line[1000];

	  cache =
	    (pict_type *) xrealloc (cache,
				    (n_cache + 1) * sizeof (pict_type));
	  memset (&cache[n_cache], 0, sizeof (pict_type));
	  cache[n_cache].name = xstrdup (cp);
	  while (fgets (line, sizeof (line), fp)) {
	    cp = strchr (line, ':');
	    if (*cp == ':') {
	      cp = patch_line (line, cp);
	      if (cache[n_cache].time == NULL &&
		  strcmp (line, "Create Date") == 0) {
		double tim;

	        free (pict[n_pict].time);
		cache[n_cache].time = xstrdup (cp);
		tim = convert_time (cp);
		if (tim != 0) {
		  time_t t;

		  cache[n_cache].tim = tim;
		  t = tim;
		  printf ("Cache %s (%s) %s", cache[n_cache].name, cp,
			  ctime (&t));
		}
	      }
	      else if (strcmp (line, "Make") == 0) {
	        free (pict[n_pict].manufacturer);
		cache[n_cache].manufacturer = xstrdup (cp);
	      }
	      else if (strcmp (line, "Camera Model Name") == 0) {
	        free (pict[n_pict].model);
		cache[n_cache].model = xstrdup (cp);
	      }
	      else if (strcmp (line, "Exposure Time") == 0) {
	        free (pict[n_pict].exposure_time);
		cache[n_cache].exposure_time = xstrdup (cp);
	      }
	      else if (strcmp (line, "F Number") == 0) {
	        free (pict[n_pict].f_number);
		cache[n_cache].f_number = xstrdup (cp);
	      }
	      else if (strcmp (line, "ISO") == 0) {
	        free (pict[n_pict].iso_speed_ratings);
		cache[n_cache].iso_speed_ratings = xstrdup (cp);
	      }
	      else if (strcmp (line, "Flash") == 0) {
	        free (pict[n_pict].flash);
		cache[n_cache].flash = xstrdup (cp);
	      }
	      else if (strcmp (line, "Duration") == 0) {
	        free (pict[n_pict].duration);
		cache[n_cache].duration = xstrdup (cp);
	      }
	      else if (strcmp (line, "Image Width") == 0) {
	        free (pict[n_pict].pixel_x_dimension);
		cache[n_cache].pixel_x_dimension = xstrdup (cp);
	      }
	      else if (strcmp (line, "Image Height") == 0) {
	        free (pict[n_pict].pixel_y_dimension);
		cache[n_cache].pixel_y_dimension = xstrdup (cp);
	      }
	      else if (strcmp (line, "Focal Length In 35mm Format") == 0) {
	        free (pict[n_pict].focal_length_in_35mm);
		cache[n_cache].focal_length_in_35mm = xstrdup (cp);
	      }
	    }
	  }
	  n_cache++;
	  fclose (fp);
	}
      }
      free (name);
    }
    closedir (dir);
  }
  free (dname);
}

static void
write_cache (char *output)
{
  unsigned int i;

  for (i = 0; i < n_pict; i++) {
    char *lower;
    char *command;
    FILE *fo;

    lower = xstrdup (pict[i].name);
    make_lower (lower);
    command =
      str_concat (output, FILE_SEP_STR, "cache", FILE_SEP_STR,
		  find_char (lower, FILE_SEP_CHR), STR_END);
    fo = fopen (command, "wb");
    free (command);
    if (pict[i].time) {
      fprintf (fo, "Create Date : %s\n", pict[i].time);
    }
    if (pict[i].manufacturer) {
      fprintf (fo, "Make : %s\n", pict[i].manufacturer);
    }
    if (pict[i].model) {
      fprintf (fo, "Camera Model Name : %s\n", pict[i].model);
    }
    if (pict[i].exposure_time) {
      fprintf (fo, "Exposure Time : %s\n", pict[i].exposure_time);
    }
    if (pict[i].f_number) {
      fprintf (fo, "F Number : %s\n", pict[i].f_number);
    }
    if (pict[i].iso_speed_ratings) {
      fprintf (fo, "ISO : %s\n", pict[i].iso_speed_ratings);
    }
    if (pict[i].flash) {
      fprintf (fo, "Flash : %s\n", pict[i].flash);
    }
    if (pict[i].duration) {
      fprintf (fo, "Duration : %s\n", pict[i].duration);
    }
    if (pict[i].pixel_x_dimension) {
      fprintf (fo, "Image Width : %s\n", pict[i].pixel_x_dimension);
    }
    if (pict[i].pixel_y_dimension) {
      fprintf (fo, "Image Height : %s\n", pict[i].pixel_y_dimension);
    }
    if (pict[i].focal_length_in_35mm) {
      fprintf (fo, "Focal Length In 35mm Format : %s\n",
	       pict[i].focal_length_in_35mm);
    }
    fclose (fo);
    free (lower);
  }
}

static void
load_dir (const char *dir_name)
{
  DIR *dir;
  struct stat st;

  dir = opendir (dir_name);
  if (dir) {
    struct dirent *dirent;

    while ((dirent = readdir (dir)) != NULL) {
      char *name =
	str_concat (dir_name, FILE_SEP_STR, dirent->d_name, STR_END);

      if (stat (name, &st) == 0) {
	char *cp = find_char (name, '.');

	if ((st.st_mode & S_IFMT) == S_IFDIR) {
	  if (use_recursive) {
	    load_dir (name);
	  }
	}
	else if (strcmp (cp, "gpx") == 0 || strcmp (cp, "GPX") == 0) {
	  load_gpx (name);
	}
	else if (strcmp (cp, "jpg") == 0 || strcmp (cp, "JPG") == 0) {
	  load_pict (name, 0);
	}
	else if (use_video &&
		 (strcmp (cp, "mp4") == 0 || strcmp (cp, "MP4") == 0 ||
		  strcmp (cp, "mov") == 0 || strcmp (cp, "MOV") == 0 ||
		  strcmp (cp, "mts") == 0 || strcmp (cp, "MTS") == 0)) {
	  load_pict (name, 1);
	}
      }
      free (name);
    }
    closedir (dir);
  }
}

static void
create_image (char *output, const char *data, unsigned int size,
	      const char *file_name)
{
  FILE *fo;
  char *name =
    str_concat (output, FILE_SEP_STR, "images", FILE_SEP_STR, file_name,
		STR_END);

  fo = fopen (name, "wb");
  if (fo) {
    fwrite (data, 1, size, fo);
    fclose (fo);
  }
  free (name);
}

int
main (int argc, char **argv)
{
  int i;
  int j;
  int k;
  FILE *fo;
  char *cp;
  char *tp;
  char *base;
  char *lower;
  char *video;
  char *output = (char *) "output";
  int height = 450;
  int width = 0;
  int vheight = 0;
  int vwidth = 320;
  int vkheight = 0;
  int vkwidth = 640;
  int framerate = 3;
  int show_points = 0;
  double offset = 0;
  gpx_data_type *last;
  gpx_data_type *best;
  double total_distance;
  struct stat st;
  time_t start;
  time_t end;
  char *command;
  char line[1000];

  time (&start);
  if (argc == 1) {
    printf ("Usage: %s [options] <gpx files> <jpg files> <movie files>\n\n", argv[0]);
    printf ("Options:\n");
    printf ("  --offset=x       gpx offset in seconds\n");
    printf ("  --output=x       output directory name (default 'output')\n");
    printf ("  --show-points=x  put gpx points in kmz file\n");
    printf ("  --width=x        resized image width (default %d)\n", width);
    printf ("  --height=x       resized image height (default %d)\n", height);
    printf ("  --video-width=x  resized video width (default %d)\n", vwidth);
    printf ("  --video-height=x resized video height (default %d)\n",
	    vheight);
    printf ("  --kml-width=x    resized kml video width (default %d)\n",
	    vkwidth);
    printf ("  --kml-height=x   resized kml video height (default %d)\n",
	    vkheight);
    printf ("  --framerate      framerate animated gif in Hz. (default %d)\n",
	    framerate);
    printf ("  --use-video      use video files (animated gif)\n");
    printf ("  --use-jhead      use jhead instead of exiftool\n");
    printf ("  --use-exiftool   use exiftool instead of jhead\n");
    printf ("  --use-cache      use cache\n");
    printf ("  --recursive      read dirs recursive\n");
    printf ("  --fix-mp4=x      fix mp4 time problem in seconds\n");
    return 0;
  }
  track_name = NULL;
  n_track = 0;
  track = NULL;
  n_pict = 0;
  pict = NULL;
  n_cache = 0;
  cache = NULL;
  if (use_cache) {
    read_cache (output);
  }
  for (i = 1; i < argc; i++) {
    state = 0;
    n_gpx_data = 0;
    gpx_data = NULL;
    if (strncmp (argv[i], "--offset", strlen ("--offset")) == 0) {
      if (argv[i][strlen ("--offset")] == '=') {
	offset = atof (&argv[i][strlen ("--offset=")]);
      }
      else if (++i < argc) {
	offset = atof (argv[i]);
      }
    }
    else if (strncmp (argv[i], "--output", strlen ("--output")) == 0) {
      if (argv[i][strlen ("--output")] == '=') {
	output = &argv[i][strlen ("--output=")];
      }
      else if (++i < argc) {
	output = argv[i];
      }
      if (use_cache) {
	read_cache (output);
      }
    }
    else if (strncmp (argv[i], "--show-points",
		      strlen ("--show-points")) == 0) {
      if (argv[i][strlen ("--show-points")] == '=') {
	show_points = atoi (&argv[i][strlen ("--show-points=")]);
      }
      else if (++i < argc) {
	show_points = atoi (argv[i]);
      }
      if (show_points < 0) {
	fprintf (stderr, "Illegal show-points: %d\n", show_points);
	exit (1);
      }
    }
    else if (strncmp (argv[i], "--width", strlen ("--width")) == 0) {
      if (argv[i][strlen ("--width")] == '=') {
	width = atoi (&argv[i][strlen ("--width=")]);
      }
      else if (++i < argc) {
	width = atoi (argv[i]);
      }
      if (width < 0) {
	fprintf (stderr, "Illegal width: %d\n", width);
	exit (1);
      }
    }
    else if (strncmp (argv[i], "--height", strlen ("--height")) == 0) {
      if (argv[i][strlen ("--height")] == '=') {
	height = atoi (&argv[i][strlen ("--height=")]);
      }
      else if (++i < argc) {
	height = atoi (argv[i]);
      }
      if (height < 0) {
	fprintf (stderr, "Illegal height: %d\n", height);
	exit (1);
      }
    }
    else if (strncmp (argv[i], "--video-width", strlen ("--video-width")) ==
	     0) {
      if (argv[i][strlen ("--video-width")] == '=') {
	vwidth = atoi (&argv[i][strlen ("--video-width=")]);
      }
      else if (++i < argc) {
	vwidth = atoi (argv[i]);
      }
      if (vwidth < 0) {
	fprintf (stderr, "Illegal video width: %d\n", vwidth);
	exit (1);
      }
    }
    else if (strncmp (argv[i], "--video-height", strlen ("--video-height")) ==
	     0) {
      if (argv[i][strlen ("--video-height")] == '=') {
	vheight = atoi (&argv[i][strlen ("--video-height=")]);
      }
      else if (++i < argc) {
	vheight = atoi (argv[i]);
      }
      if (vheight < 0) {
	fprintf (stderr, "Illegal video height: %d\n", vheight);
	exit (1);
      }
    }
    else if (strncmp (argv[i], "--kml-width", strlen ("--kml-width")) == 0) {
      if (argv[i][strlen ("--video-kml")] == '=') {
	vkwidth = atoi (&argv[i][strlen ("--video-kml=")]);
      }
      else if (++i < argc) {
	vkwidth = atoi (argv[i]);
      }
      if (vkwidth < 0) {
	fprintf (stderr, "Illegal video kml width: %d\n", vkwidth);
	exit (1);
      }
    }
    else if (strncmp (argv[i], "--kml-height", strlen ("--kml-height")) == 0) {
      if (argv[i][strlen ("--kml-height")] == '=') {
	vkheight = atoi (&argv[i][strlen ("--kml-height=")]);
      }
      else if (++i < argc) {
	vkheight = atoi (argv[i]);
      }
      if (vkheight < 0) {
	fprintf (stderr, "Illegal video kml height: %d\n", vkheight);
	exit (1);
      }
    }
    else if (strncmp (argv[i], "--framerate", strlen ("--framerate")) == 0) {
      if (argv[i][strlen ("--framerate")] == '=') {
	framerate = atoi (&argv[i][strlen ("--framerate=")]);
      }
      else if (++i < argc) {
	framerate = atoi (argv[i]);
      }
      if (framerate <= 1) {
	fprintf (stderr, "Illegal frame rate: %d\n", framerate);
	exit (1);
      }
    }
    else if (strncmp (argv[i], "--use-video", strlen ("--use-video")) == 0) {
      use_video = 1;
    }
    else if (strncmp (argv[i], "--use-jhead", strlen ("--use-jhead")) == 0) {
      use_jhead = 1;
      use_exiftool = 0;
    }
    else if (strncmp (argv[i], "--use-exiftool", strlen ("--use-exiftool")) ==
	     0) {
      use_exiftool = 1;
      use_jhead = 0;
    }
    else if (strncmp (argv[i], "--use-cache", strlen ("--use-cache")) == 0) {
      use_cache = 1;
    }
    else if (strncmp (argv[i], "--recursive", strlen ("--recursive")) == 0) {
      use_recursive = 1;
    }
    else if (strncmp (argv[i], "--fix-mp4", strlen ("--fix-mp4")) == 0) {
      if (argv[i][strlen ("--fix-mp4")] == '=') {
	fix_mp4 = atoi (&argv[i][strlen ("--fix-mp4=")]);
      }
      else if (++i < argc) {
	fix_mp4 = atoi (argv[i]);
      }
    }
    else if (stat (argv[i], &st) == 0) {
      cp = find_char (argv[i], '.');
      if ((st.st_mode & S_IFMT) == S_IFDIR) {
	load_dir (argv[i]);
      }
      else if (strcmp (cp, "gpx") == 0 || strcmp (cp, "GPX") == 0) {
	load_gpx (argv[i]);
      }
      else if (strcmp (cp, "jpg") == 0 || strcmp (cp, "JPG") == 0) {
	load_pict (argv[i], 0);
      }
      else if (use_video &&
	       (strcmp (cp, "mp4") == 0 || strcmp (cp, "MP4") == 0 ||
		strcmp (cp, "mov") == 0 || strcmp (cp, "MOV") == 0 ||
		strcmp (cp, "mts") == 0 || strcmp (cp, "MTS") == 0)) {
	load_pict (argv[i], 1);
      }
    }
  }
  if (width == 0 && height == 0) {
    fprintf (stderr, "Illegal width/height: %d/%d\n", width, height);
    exit (1);
  }
  if (vwidth == 0 && vheight == 0) {
    fprintf (stderr, "Illegal video-width/video-height: %d/%d\n", vwidth,
	     vheight);
    exit (1);
  }
  if (vkwidth == 0 && vkheight == 0) {
    fprintf (stderr, "Illegal kml-width/kml-height: %d/%d\n", vkwidth,
	     vkheight);
    exit (1);
  }
  SSORT (pict, n_pict, sizeof (pict_type), sort_picts);
  SSORT (track, n_track, sizeof (track_type), sort_tracks);
  MKDIR (output);
  command = str_concat (output, FILE_SEP_STR, "images", STR_END);
  MKDIR (command);
  free (command);
  create_image (output, camera, sizeof (camera), "camera.png");
  if (use_video) {
    create_image (output, video_camera, sizeof (video_camera),
		  "video-camera.png");
  }
  if (show_points) {
    create_image (output, track_none, sizeof (track_none), "track-none.png");
  }
  if (use_cache) {
    command = str_concat (output, FILE_SEP_STR, "cache", STR_END);
    MKDIR (command);
    free (command);
  }
  command = str_concat (output, FILE_SEP_STR, "base.kml", STR_END);
  fo = fopen (command, "wb");
  free (command);
  if (fo == NULL) {
    fprintf (stderr, "Cannot create %s/base.kml\n", output);
    exit (1);
  }
  total_distance = 0;
  for (i = 0; i < n_track; i++) {
    total_distance += calc_total_distance (&track[i]);
  }
  fprintf (fo, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
  fprintf (fo, "<Document xmlns:xlink=\"http://www.w3/org/1999/xlink\">\n");
  fprintf (fo, "<name>%s</name>\n", output);
  fprintf (fo, "<Style id=\"photo_mark\">\n");
  fprintf (fo, "  <IconStyle>\n");
  fprintf (fo, "  <scale>0.5</scale>\n");
  fprintf (fo, "    <Icon>\n");
  fprintf (fo, "      <href>images/camera.png</href>\n");
  fprintf (fo, "    </Icon>\n");
  fprintf (fo, "  </IconStyle>\n");
  fprintf (fo, "  <LabelStyle>\n");
  fprintf (fo, "    <scale>0.2</scale>\n");
  fprintf (fo, "  </LabelStyle>\n");
  fprintf (fo, "</Style>\n");
  fprintf (fo, "<Style id=\"video_mark\">\n");
  fprintf (fo, "  <IconStyle>\n");
  fprintf (fo, "  <scale>0.5</scale>\n");
  fprintf (fo, "    <Icon>\n");
  fprintf (fo, "      <href>images/video-camera.png</href>\n");
  fprintf (fo, "    </Icon>\n");
  fprintf (fo, "  </IconStyle>\n");
  fprintf (fo, "  <LabelStyle>\n");
  fprintf (fo, "    <scale>0.2</scale>\n");
  fprintf (fo, "  </LabelStyle>\n");
  fprintf (fo, "</Style>\n");
  if (show_points) {
    fprintf (fo, "<Style id=\"point_n\">\n");
    fprintf (fo, "  <IconStyle>\n");
    fprintf (fo, "    <scale>0.5</scale>\n");
    fprintf (fo, "    <Icon>\n");
    fprintf (fo, "      <href>images/track-none.png</href>\n");
    fprintf (fo, "    </Icon>\n");
    fprintf (fo, "  </IconStyle>\n");
    fprintf (fo, "  <LabelStyle>\n");
    fprintf (fo, "    <scale>0</scale>\n");
    fprintf (fo, "   </LabelStyle>\n");
    fprintf (fo, "</Style>\n");
    fprintf (fo, "<Style id=\"point_h\">\n");
    fprintf (fo, "  <IconStyle>\n");
    fprintf (fo, "    <scale>1.2</scale>\n");
    fprintf (fo, "    <Icon>\n");
    fprintf (fo, "      <href>images/track-none.png</href>\n");
    fprintf (fo, "    </Icon>\n");
    fprintf (fo, "  </IconStyle>\n");
    fprintf (fo, "</Style>\n");
    fprintf (fo, "<StyleMap id=\"point\">\n");
    fprintf (fo, "  <Pair>\n");
    fprintf (fo, "    <key>normal</key>\n");
    fprintf (fo, "    <styleUrl>#point_n</styleUrl>\n");
    fprintf (fo, "  </Pair>\n");
    fprintf (fo, "  <Pair>\n");
    fprintf (fo, "    <key>highlight</key>\n");
    fprintf (fo, "    <styleUrl>#point_h</styleUrl>\n");
    fprintf (fo, "  </Pair>\n");
    fprintf (fo, "</StyleMap>\n");
  }
  fprintf (fo, "<Folder>\n");
  fprintf (fo, "  <name>Images</name>\n");
  fprintf (fo, "  <Snippet>Distance: %.3f</Snippet>\n",
	   total_distance / 1000.0);
  for (i = 0; i < n_pict; i++) {
    double min;

    min = 1e20;
    best = NULL;
    for (j = 0; j < n_track; j++) {
      for (k = 0; k < track[j].n_gpx_data; k++) {
	double tim = track[j].gpx_data[k].tim + offset;

	if (fabs (tim - pict[i].tim) < min) {
	  min = fabs (tim - pict[i].tim);
	  best = &track[j].gpx_data[k];
	}
      }
    }
    if (best) {
      time_t now;
      struct tm *loc_tm;
      double distance = 0;
      double lat = 0;
      double lon = 0;
      double ele = 0;
      double minl;

      minl = 1e20;
      last = NULL;
      for (j = 0; j < n_track; j++) {
	for (k = 0; k < track[j].n_gpx_data; k++) {
	  double tim = track[j].gpx_data[k].tim + offset;

	  if (best != &track[j].gpx_data[k] &&
	      fabs (tim - pict[i].tim) < minl) {
	    minl = fabs (tim - pict[i].tim);
	    last = &track[j].gpx_data[k];
	  }
	}
      }
      if (best->lat) {
	lat = strtod (best->lat, NULL);
      }
      if (best->lon) {
	lon = strtod (best->lon, NULL);
      }
      if (best->ele) {
	ele = strtod (best->ele, NULL);
      }
      if (last && last->lat && last->lon && last->ele &&
	  min != 0 && best->tim != last->tim &&
	  min < fabs (best->tim - last->tim)) {
	double latl = strtod (last->lat, NULL);
	double lonl = strtod (last->lon, NULL);
	double elel = strtod (last->ele, NULL);
	double latn;
	double lonn;
	double elen;

	latn = lat - (lat - latl) * min / fabs (best->tim - last->tim);
	lonn = lon - (lon - lonl) * min / fabs (best->tim - last->tim);
	elen = ele - (ele - elel) * min / fabs (best->tim - last->tim);
	distance = calc_distance (lonn, lon, latn, lat);
	if (isnan (distance)) {
	  distance = 0.0;
	}
	lat = latn;
	lon = lonn;
	ele = elen;
      }
      base = find_char (pict[i].name, FILE_SEP_CHR);
      printf ("%s best=%s distance=%.0f diff=%.0f\n", base, best->time,
	      distance, min);
      lower = xstrdup (pict[i].name);
      make_lower (lower);
      cp = find_char (lower, FILE_SEP_CHR);
      video = xstrdup (cp);
      if (pict[i].is_video) {
	tp = strrchr (video, '.');
	if (tp) {
	  *tp = 0;
	  tp = str_concat (video, ".gif", STR_END);
	  free (video);
	  video = tp;
	}
      }
      fprintf (fo, "  <Placemark>\n");
      fprintf (fo, "    <name>%s</name>\n", base);
      fprintf (fo, "    <description><![CDATA[");
      fprintf (fo, "<html xmlns=\"http://www.w3.org/1999/xhtml\">\n");
      fprintf (fo, "    <head><title>%s</title></head>\n    <body>\n", cp);
      if (pict[i].is_video == 0) {
	fprintf (fo, "      <img src=\"images/%s\"", cp);
	if (height) {
	  fprintf (fo, " height=\"%d\"", height);
	}
	if (width) {
	  fprintf (fo, " width=\"%d\"", width);
	}
      }
      else {
	fprintf (fo, "      <img src=\"images/%s\"", video);
	if (vkheight) {
	  fprintf (fo, " height=\"%d\"", vkheight);
	}
	if (vkwidth) {
	  fprintf (fo, " width=\"%d\"", vkwidth);
	}
      }
      fprintf (fo, "/>\n");
      fprintf (fo, "      <table>\n");
      if (best->lon || pict[i].manufacturer) {
	fprintf (fo, "        <tr>");
	if (best->lon) {
	  fprintf (fo, "<td>Longitude: %.8f</td>", lon);
	}
	else {
	  fprintf (fo, "<td></td>");
	}
	if (pict[i].manufacturer) {
	  fprintf (fo, "<td>Manufacturer: %s</td>", pict[i].manufacturer);
	}
	else {
	  fprintf (fo, "<td></td>");
	}
	fprintf (fo, "</tr>\n");
      }
      if (best->lat || pict[i].model) {
	fprintf (fo, "        <tr>");
	if (best->lat) {
	  fprintf (fo, "<td>Latitude: %.8f</td>", lat);
	}
	else {
	  fprintf (fo, "<td></td>");
	}
	if (pict[i].model) {
	  fprintf (fo, "<td>Model: %s</td>", pict[i].model);
	}
	else {
	  fprintf (fo, "<td></td>");
	}
	fprintf (fo, "</tr>\n");
      }
      if (best->ele || pict[i].exposure_time) {
	fprintf (fo, "        <tr>");
	if (best->ele) {
	  fprintf (fo, "<td>Altitude: %.2f m</td>", ele);
	}
	else {
	  fprintf (fo, "<td></td>");
	}
	if (pict[i].exposure_time) {
	  fprintf (fo, "<td>Exposure Time: %s</td>", pict[i].exposure_time);
	}
	else {
	  fprintf (fo, "<td></td>");
	}
	fprintf (fo, "</tr>\n");
      }
      if (best->total_distance || pict[i].f_number) {
	fprintf (fo, "        <tr>");
	if (best->total_distance) {
	  fprintf (fo, "<td>Distance: %.3f km</td>",
		   best->total_distance / 1000.0);
	}
	else {
	  fprintf (fo, "<td></td>");
	}
	if (pict[i].f_number) {
	  fprintf (fo, "<td>F Number: %s</td>", pict[i].f_number);
	}
	else {
	  fprintf (fo, "<td></td>");
	}
	fprintf (fo, "</tr>\n");
      }
      if (best->speed || pict[i].iso_speed_ratings) {
	fprintf (fo, "        <tr>");
	if (best->speed) {
	  fprintf (fo, "<td>Speed: %.1f km/h</td>", best->speed * 3.6);
	}
	else {
	  fprintf (fo, "<td></td>");
	}
	if (pict[i].iso_speed_ratings) {
	  fprintf (fo, "<td>Iso Speed Ratings: %s</td>",
		   pict[i].iso_speed_ratings);
	}
	else {
	  fprintf (fo, "<td></td>");
	}
	fprintf (fo, "</tr>\n");
      }
      if (best->heading ||
	  (pict[i].is_video == 0 && pict[i].flash) ||
	  (pict[i].is_video == 1 && pict[i].duration)) {
	fprintf (fo, "        <tr>");
	if (best->heading) {
	  fprintf (fo, "<td>Heading: %.1f</td>", best->heading);
	}
	else {
	  fprintf (fo, "<td></td>");
	}
	if (pict[i].is_video == 0 && pict[i].flash) {
	  fprintf (fo, "<td>Flash: %s</td>", pict[i].flash);
	}
	if (pict[i].is_video == 1 && pict[i].duration) {
	  fprintf (fo, "<td>Duration: %s</td>", pict[i].duration);
	}
	else {
	  fprintf (fo, "<td></td>");
	}
	fprintf (fo, "</tr>\n");
      }
      now = pict[i].tim;
      loc_tm = localtime (&now);
      strftime (line, sizeof (line), "%a %d %b %Y %H:%M:%S", loc_tm);
      fprintf (fo, "        <tr><td>Time: %s</td>", line);
      if (pict[i].pixel_x_dimension) {
	fprintf (fo, "<td>Pixel X Dimension: %s</td>",
		 pict[i].pixel_x_dimension);
      }
      else {
	fprintf (fo, "<td></td>");
      }
      fprintf (fo, "</tr>\n");
      fprintf (fo, "        <tr><td>Gps offset: %.0f seconds</td>", min);
      if (pict[i].pixel_y_dimension) {
	fprintf (fo, "<td>Pixel Y Dimension: %s</td>",
		 pict[i].pixel_y_dimension);
      }
      else {
	fprintf (fo, "<td></td>");
      }
      fprintf (fo, "</tr>\n");
      fprintf (fo, "        <tr><td>Gps distance: %.0f m</td>", distance);
      if (pict[i].focal_length_in_35mm) {
	fprintf (fo, "<td>Focal Length in 35mm: %s</td>",
		 pict[i].focal_length_in_35mm);
      }
      else {
	fprintf (fo, "<td></td>");
      }
      fprintf (fo, "</tr>\n");
      fprintf (fo, "      </table>\n");
      fprintf (fo, "    </body></html>");
      fprintf (fo, "]]></description>\n");
      fprintf (fo, "    <Snippet>%s</Snippet>\n", base);
      if (pict[i].is_video == 0) {
	fprintf (fo, "    <styleUrl>#photo_mark</styleUrl>\n");
      }
      else {
	fprintf (fo, "    <styleUrl>#video_mark</styleUrl>\n");
      }
      if (best->lat && best->lon && best->ele) {
	fprintf (fo, "    <Point><coordinates>");
	fprintf (fo, "%.8f,%.8f,%.8f</coordinates></Point>\n", lon, lat, ele);
      }
      else if (best->lat && best->lon) {
	fprintf (fo, "    <Point><coordinates>");
	fprintf (fo, "%.8f,%.8f,%.8f</coordinates></Point>\n", lon, lat, 0.0);
      }
      fprintf (fo, "  </Placemark>\n");
      command =
	str_concat (output, FILE_SEP_STR, "images", FILE_SEP_STR,
		    pict[i].is_video == 0 ? cp : video, STR_END);
      if (stat (command, &st) != 0) {
	free (command);
	if (pict[i].is_video == 0) {
	  line[0] = '\0';
	  if (width) {
	    sprintf (&line[strlen (line)], "%d", width);
	  }
	  if (height) {
	    sprintf (&line[strlen (line)], "x%d", height);
	  }
	  command =
	    str_concat ("convert -strip -resize ", line, " -quality 50 ",
			pict[i].name, " ", output, FILE_SEP_STR, "images",
			FILE_SEP_STR, cp, STR_END);
	}
	else {
	  int w = vwidth;
	  int h = vheight;
	  int hs = 16;
	  int vs = 9;
	  int fs = 200;
	  char rate[20];
	  char timestamp[1000];

	  if (pict[i].pixel_x_dimension && pict[i].pixel_y_dimension) {
	    hs = atoi (pict[i].pixel_x_dimension);
	    vs = atoi (pict[i].pixel_y_dimension);
	    fs = vs / 10;
	  }
	  if (w == 0) {
	    w = h * hs / vs;
	  }
	  if (h == 0) {
	    h = w * vs / hs;
	  }
	  sprintf (line, "%dx%d", w, h);
	  sprintf (rate, "%d", framerate);
	  sprintf (timestamp,
		   "-vf drawtext=\"text='%%{pts\\:localtime\\:0\\:"
		   "%%M\\\\\\\\\\:%%S}':fontcolor=white:fontsize=%d:"
		   "x=(w-text_w)-10:y=(h-text_h)-10\"", fs);
	  command =
	    str_concat ("ffmpeg -loglevel -8 -y -i ", pict[i].name, " -s ",
			line, " -r ", rate, " ", timestamp, " ", output,
			FILE_SEP_STR, "images", FILE_SEP_STR, video, STR_END);
	}
	system (command);
	free (command);
      }
      else {
	free (command);
      }
      free (lower);
      free (video);
    }
    else {
      printf ("%s NOT FOUND\n", find_char (pict[i].name, FILE_SEP_CHR));
    }
  }
  fprintf (fo, "</Folder>\n");
  fprintf (fo, "<Style id=\"track\">\n");
  fprintf (fo, "  <LineStyle>\n");
  fprintf (fo, "    <color>FFE600E6</color>\n");
  fprintf (fo, "    <width>6</width>\n");
  fprintf (fo, "  </LineStyle>\n");
  fprintf (fo, "</Style>\n");
  if (show_points) {
    fprintf (fo, "<Folder>\n");
    fprintf (fo, "  <name>Points</name>\n");
    for (i = 0; i < n_track; i++) {
      fprintf (fo, "  <Folder>\n");
      fprintf (fo, "    <name>%s</name>\n",
	       track[i].track_name ? track[i].track_name : "Track");
      fprintf (fo, "    <Snippet>Distance: %.3f</Snippet>\n",
	       calc_total_distance (&track[i]) / 1000.0);
      total_distance = 0;
      for (j = 0; j < track[i].n_gpx_data; j++) {
	double distance = 0.0;
	double speed = 0.0;
	double heading = 0.0;

	best = &track[i].gpx_data[j];
	if (j > 0) {
	  last = &track[i].gpx_data[j - 1];
	  calc (last->lat, last->lon, last->tim,
		best->lat, best->lon, best->tim, &distance, &speed, &heading);
	  total_distance += distance;
	}
	if ((j % show_points) == 0) {
	  fprintf (fo, "    <Placemark>\n");
	  fprintf (fo, "      <name>%d</name>\n", j + 1);
	  fprintf (fo, "      <when>%s</when>\n", best->time);
	  fprintf (fo, "      <description><![CDATA[");
	  fprintf (fo, "<html xmlns=\"http://www.w3.org/1999/xhtml\">\n");
	  fprintf (fo, "    <body>\n");
	  fprintf (fo, "        <table>\n");
	  if (best->lon) {
	    fprintf (fo, "          <tr><td>Longitude: %s</td></tr>\n",
		     best->lon);
	  }
	  if (best->lat) {
	    fprintf (fo, "          <tr><td>Latitude: %s</td></tr>\n",
		     best->lat);
	  }
	  if (best->ele) {
	    fprintf (fo, "          <tr><td>Altitude: %s m</td></tr>\n",
		     best->ele);
	  }
	  if (total_distance) {
	    fprintf (fo, "          <tr><td>Distance: %.3f km</td></tr>\n",
		     total_distance / 1000.0);
	  }
	  if (speed) {
	    fprintf (fo, "          <tr><td>Speed: %.1f km/h</td></tr>\n",
		     speed * 3.6);
	  }
	  if (heading) {
	    fprintf (fo, "          <tr><td>Heading: %.1f</td></tr>\n",
		     heading);
	  }
	  if (best->time) {
	    fprintf (fo, "          <tr><td>Time: %s</td></tr>\n",
		     best->time);
	  }
	  fprintf (fo, "        </table>\n");
	  fprintf (fo, "    </body></html>");
	  fprintf (fo, "]]></description>\n");
	  if (best->time) {
	    fprintf (fo, "      <TimeStamp><when>%s</when></TimeStamp>\n",
		     best->time);
	  }
	  fprintf (fo, "      <styleUrl>#point</styleUrl>\n");
	  if (best->lat && best->lon && best->ele) {
	    fprintf (fo, "      <Point><coordinates>");
	    fprintf (fo, "%s,%s,%s</coordinates></Point>\n",
		     best->lon, best->lat, best->ele);
	  }
	  else if (best->lat && best->lon) {
	    fprintf (fo, "      <Point><coordinates>");
	    fprintf (fo, "%s,%s</coordinates></Point>\n", best->lon,
		     best->lat);
	  }
	  fprintf (fo, "    </Placemark>\n");
	}
      }
      fprintf (fo, "  </Folder>\n");
    }
    fprintf (fo, "</Folder>\n");
  }
  fprintf (fo, "<Folder>\n");
  fprintf (fo, "  <name>Tracks</name>\n");
  for (i = 0; i < n_track; i++) {
    fprintf (fo, "  <Placemark>\n");
    fprintf (fo, "    <name>%s</name>\n",
	     track[i].track_name ? track[i].track_name : "Track");
    fprintf (fo, "    <Snippet>Distance: %.3f</Snippet>\n",
	     calc_total_distance (&track[i]) / 1000.0);
    fprintf (fo, "    <styleUrl>#track</styleUrl>\n");
    fprintf (fo, "    <MultiGeometry>\n");
    fprintf (fo, "      <LineString>\n");
    fprintf (fo, "        <coordinates>");
    for (j = 0; j < track[i].n_gpx_data; j++) {
      best = &track[i].gpx_data[j];
      if (best->lat && best->lon && best->ele) {
	fprintf (fo, "%s,%s,%s ", best->lon, best->lat, best->ele);
      }
      else if (best->lat && best->lon) {
	fprintf (fo, "%s,%s,%s ", best->lon, best->lat, "0");
      }
    }
    fprintf (fo, "</coordinates>\n");
    fprintf (fo, "      </LineString>\n");
    fprintf (fo, "    </MultiGeometry>\n");
    fprintf (fo, "  </Placemark>\n");
  }
  fprintf (fo, "</Folder>\n");
  fprintf (fo, "</Document>\n");
  fclose (fo);
  if (use_cache) {
    write_cache (output);
  }
  fflush (stdout);
  command = str_concat (output, ".kmz", STR_END);
  unlink (command);
  free (command);
  if (chdir (output) == 0) {
    command =
      str_concat ("7z a -tzip -r ..", FILE_SEP_STR, output,
		  ".kmz base.kml images", STR_END);
    system (command);
    free (command);
    chdir ("..");
  }
  else {
    fprintf (stderr, "chdir %s failed\n", output);
  }
  free_track (track, n_track);
  free_pict (pict, n_pict);
  free_pict (cache, n_cache);
  time (&end);
  printf ("Total time: %u seconds\n", (unsigned int) (end - start));
  return 0;
}
